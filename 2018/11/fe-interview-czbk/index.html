<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.57.0 with theme Tranquilpeak 0.4.6-BETA">
<meta name="author" content="xn213">
<meta name="keywords" content="fe-interview, 前端, 面试, 前端面试, vuejs, nodejs, node, blog, vue, vuejs, nodejs, react, development">
<meta name="description" content="web前端高频面试试题含答案 - 传智播客 本文是根据多份关于web前端面试试题抽取的企业面试时用到最多的一些试题，仅供参考。
怎么去设计一个组件封装？
 组件封装的目的是为了重用，提高开发效率和代码质量
  　2.低耦合，单一职责，可复用性，可维护性
　3.前端组件化设计思路
js 异步加载的方式
 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染
 defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序
 加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中）
  css 动画和 js 动画的差异
 代码复杂度，js 动画代码相对复杂一些
 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件
 动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好
  XSS 与 CSRF 两种跨站攻击
 xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写
 csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤
 我们没法彻底杜绝攻击，只能提高攻击门槛">


<meta property="og:description" content="web前端高频面试试题含答案 - 传智播客 本文是根据多份关于web前端面试试题抽取的企业面试时用到最多的一些试题，仅供参考。
怎么去设计一个组件封装？
 组件封装的目的是为了重用，提高开发效率和代码质量
  　2.低耦合，单一职责，可复用性，可维护性
　3.前端组件化设计思路
js 异步加载的方式
 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染
 defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序
 加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中）
  css 动画和 js 动画的差异
 代码复杂度，js 动画代码相对复杂一些
 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件
 动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好
  XSS 与 CSRF 两种跨站攻击
 xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写
 csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤
 我们没法彻底杜绝攻击，只能提高攻击门槛">
<meta property="og:type" content="article">
<meta property="og:title" content="Fe Interview Czbk">
<meta name="twitter:title" content="Fe Interview Czbk">
<meta property="og:url" content="https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/">
<meta property="twitter:url" content="https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/">
<meta property="og:site_name" content="xn213">
<meta property="og:description" content="web前端高频面试试题含答案 - 传智播客 本文是根据多份关于web前端面试试题抽取的企业面试时用到最多的一些试题，仅供参考。
怎么去设计一个组件封装？
 组件封装的目的是为了重用，提高开发效率和代码质量
  　2.低耦合，单一职责，可复用性，可维护性
　3.前端组件化设计思路
js 异步加载的方式
 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染
 defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序
 加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中）
  css 动画和 js 动画的差异
 代码复杂度，js 动画代码相对复杂一些
 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件
 动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好
  XSS 与 CSRF 两种跨站攻击
 xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写
 csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤
 我们没法彻底杜绝攻击，只能提高攻击门槛">
<meta name="twitter:description" content="web前端高频面试试题含答案 - 传智播客 本文是根据多份关于web前端面试试题抽取的企业面试时用到最多的一些试题，仅供参考。
怎么去设计一个组件封装？
 组件封装的目的是为了重用，提高开发效率和代码质量
  　2.低耦合，单一职责，可复用性，可维护性
　3.前端组件化设计思路
js 异步加载的方式
 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染
 defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序
 加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中）
  css 动画和 js 动画的差异
 代码复杂度，js 动画代码相对复杂一些
 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件
 动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好
  XSS 与 CSRF 两种跨站攻击
 xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写
 csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤
 我们没法彻底杜绝攻击，只能提高攻击门槛">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2018-11-28T01:21:13">
  
  
    <meta property="article:modified_time" content="2018-11-28T01:21:13">
  
  
  
    
      <meta property="article:section" content="面试">
    
  
  
    
      <meta property="article:tag" content="前端">
    
      <meta property="article:tag" content="面试">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://xn213.github.io/hugo-blog/images/FE-Interview.png">
  <meta property="twitter:image" content="https://xn213.github.io/hugo-blog/images/FE-Interview.png">


  <meta property="og:image" content="https://xn213.github.io/hugo-blog/images/ruoxiyy.jpg">
  <meta property="twitter:image" content="https://xn213.github.io/hugo-blog/images/ruoxiyy.jpg">




  <meta property="og:image" content="https://s.gravatar.com/avatar/7360686615b1a1a30eecc7fed5cd7171?s=80">
  <meta property="twitter:image" content="https://s.gravatar.com/avatar/7360686615b1a1a30eecc7fed5cd7171?s=80">


    <title>Fe Interview Czbk</title>

    <link rel="icon" href="https://xn213.github.io/hugo-blog/favicon.png">
    

    

    <link rel="canonical" href="https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://xn213.github.io/hugo-blog/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://xn213.github.io/hugo-blog/">xn213</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://xn213.github.io/hugo-blog/#about">
    
    
    
      
        <img class="header-picture" src="https://s.gravatar.com/avatar/7360686615b1a1a30eecc7fed5cd7171?s=80" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://xn213.github.io/hugo-blog/#about">
          <img class="sidebar-profile-picture" src="https://s.gravatar.com/avatar/7360686615b1a1a30eecc7fed5cd7171?s=80" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">xn213</h4>
        
          <h5 class="sidebar-profile-bio">余生 倾尽天下</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xn213.github.io/hugo-blog/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xn213.github.io/hugo-blog/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">类别</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xn213.github.io/hugo-blog/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xn213.github.io/hugo-blog/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xn213.github.io/hugo-blog/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/xn213" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://xn213.github.io/hugo-blog/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-center
              post-header-cover--full"
       style="background-image:url('/hugo-blog/images/ruoxiyy.jpg')"
       data-behavior="5">
    
      <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title" itemprop="headline">
      Fe Interview Czbk
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-11-28T01:21:13&#43;08:00">
        
  November 28, 2018

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://xn213.github.io/hugo-blog/categories/%e9%9d%a2%e8%af%95">面试</a>
    
  

  </div>

</div>
    
  </div>


      <div id="main" data-behavior="5"
        class="hasCover
               hasCoverMetaIn
               hasCoverCaption">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
            <span class="post-header-cover-caption caption">文章cover图片描述</span>
          
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              

<h1 id="web前端高频面试试题含答案-传智播客">web前端高频面试试题含答案 - 传智播客</h1>

<p>本文是根据多份关于web前端面试试题抽取的企业面试时用到最多的一些试题，仅供参考。</p>

<p><strong>怎么去设计一个组件封装？</strong></p>

<ol>
<li>组件封装的目的是为了重用，提高开发效率和代码质量<br /></li>
</ol>

<p>　　2.低耦合，单一职责，可复用性，可维护性</p>

<p>　　3.前端组件化设计思路</p>

<p><strong>js 异步加载的方式</strong></p>

<ol>
<li><p>渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染</p></li>

<li><p>defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序</p></li>

<li><p>加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中）</p></li>
</ol>

<p><strong>css 动画和 js 动画的差异</strong></p>

<ol>
<li><p>代码复杂度，js 动画代码相对复杂一些</p></li>

<li><p>动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件</p></li>

<li><p>动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好</p></li>
</ol>

<p><strong>XSS 与 CSRF 两种跨站攻击</strong></p>

<ol>
<li><p>xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写</p></li>

<li><p>csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤</p></li>

<li><p>我们没法彻底杜绝攻击，只能提高攻击门槛</p></li>
</ol>

<p><strong>事件委托，目的，功能，写法</strong></p>

<ol>
<li><p>把一个或者一组元素的事件委托到它的父层或者更外层元素上</p></li>

<li><p>优点，减少内存消耗，动态绑定事件</p></li>

<li><p>target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this)</p></li>

<li><p>JavaScript 事件委托详解</p></li>
</ol>

<p><strong>线程，进程</strong></p>

<ol>
<li><p>线程是最小的执行单元，进程是最小的资源管理单元</p></li>

<li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</p></li>
</ol>

<p><strong>负载均衡</strong></p>

<ol>
<li>当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力</li>
</ol>

<p><strong>什么是CDN缓存</strong></p>

<ol>
<li><p>CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源</p></li>

<li><p>(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件</p></li>
</ol>

<p><strong>闭包的写法，闭包的作用，闭包的缺点</strong></p>

<ol>
<li><p>使用闭包的目的——隐藏变量，间接访问一个变量,在定义函数的词法作用域外，调用函数</p></li>

<li><p>闭包的内存泄露，是IE的一个 bug，闭包使用完成之后，收回不了闭包的引用，导致内存泄露</p></li>

<li><p>闭包造成内存泄露的实验</p></li>
</ol>

<p><strong>跨域问题，谁限制的跨域，怎么解决</strong></p>

<ol>
<li><p>浏览器的同源策略导致了跨域</p></li>

<li><p>用于隔离潜在恶意文件的重要安全机制</p></li>

<li><p>[jsonp ，允许 script 加载第三方资源]segmentfault.com/a/11&hellip;</p></li>

<li><p>nginx 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin *）</p></li>

<li><p>cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息</p></li>

<li><p>iframe 嵌套通讯，postmessage</p></li>
</ol>

<p><strong>javascript 中常见的内存泄露陷阱</strong></p>

<ol>
<li>内存泄露会导致一系列问题，比如：运行缓慢，崩溃，高延迟<br /></li>
</ol>

<p>　　2.内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来</p>

<p>　　3.意外的全局变量，这些都是不会被回收的变量（除非设置 null 或者被重新赋值），特别是那些用来临时存储大量信息的变量</p>

<p>　　4.周期函数一直在运行，处理函数并不会被回收，jq 在移除节点前都会，将事件监听移除</p>

<p>　　5.js 代码中有对 DOM 节点的引用，dom 节点被移除的时候，引用还维持</p>

<p>　　6.JavaScript 中 4 种常见的内存泄露陷阱</p>

<p><strong>babel把ES6转成ES5或者ES3之类的原理是什么</strong></p>

<ol>
<li>它就是个编译器，输入语言是ES6+，编译目标语言是ES5<br /></li>
</ol>

<p>　　2.babel 官方工作原理</p>

<p>　　3.解析：将代码字符串解析成抽象语法树</p>

<p>　　4.变换：对抽象语法树进行变换操作</p>

<p>　　5.再建：根据变换后的抽象语法树再生成代码字符串</p>

<p><strong>Promise 模拟终止</strong></p>

<ol>
<li>当新对象保持“pending”状态时，原Promise链将会中止执行。<br /></li>
</ol>

<p>　　2.return new Promise(()=&gt;{}); // 返回“pending”状态的Promise对象</p>

<p>　　3.从如何停掉 Promise 链说起(promise内存泄漏问题)</p>

<p><strong>promise 放在try catch里面有什么结果</strong></p>

<ol>
<li>Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获<br /></li>
</ol>

<p>　　2.当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获</p>

<p><strong>网站性能优化</strong></p>

<ol>
<li>http 请求方面，减少请求数量，请求体积，对应的做法是，对项目资源进行压缩，控制项目资源的 dns 解析在2到4个域名，提取公告的样式，公共的组件，雪碧图，缓存资源，<br /></li>
</ol>

<p>　　2.压缩资源，提取公共资源压缩，提取 css ，js 公共方法</p>

<p>　　3.不要缩放图片，使用雪碧图，使用字体图表（阿里矢量图库）</p>

<p>　　3.使用 CDN，抛开无用的 cookie</p>

<p>　　4.减少重绘重排，CSS属性读写分离，最好不要用js 修改样式，dom 离线更新，渲染前指定图片的大小</p>

<p>　　5.js 代码层面的优化，减少对字符串的计算，合理使用闭包，首屏的js 资源加载放在最底部</p>

<p><strong>js 自定义事件实现</strong></p>

<ol>
<li>原生提供了3个方法实现自定义事件<br /></li>
</ol>

<p>　　2.createEvent，设置事件类型，是 html 事件还是 鼠标事件</p>

<p>　　3.initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件</p>

<p>　　4.dispatchEvent 触发事件</p>

<p><strong>angular 双向数据绑定与vue数据的双向数据绑定</strong></p>

<ol>
<li>二者都是 MVVM 模式开发的典型代表<br /></li>
</ol>

<p>　　2.angular 是通过脏检测实现，angular 会将 UI 事件，请求事件，settimeout 这类延迟，的对象放入到事件监测的脏队列，当数据变化的时候，触发 $diget 方法进行数据的更新，视图的渲染</p>

<p>　　3.vue 通过数据属性的数据劫持和发布订阅的模式实现，大致可以理解成由3个模块组成，observer 完成对数据的劫持，compile 完成对模板片段的渲染，watcher 作为桥梁连接二者，订阅数据变化及更新视图</p>

<p><strong>get与post 通讯的区别</strong></p>

<ol>
<li>Get 请求能缓存，Post 不能<br /></li>
</ol>

<p>　　2.Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</p>

<p>　　3.Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</p>

<p>　　4.URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</p>

<p>　　5.Post 支持更多的编码类型且不对数据类型限制</p>

<p><strong>有没有去研究webpack的一些原理和机制，怎么实现的</strong></p>

<ol>
<li>解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。<br /></li>
</ol>

<p>　　2.注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。</p>

<p>　　3.从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。</p>

<p>　　4.在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。</p>

<p>　　5.递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。</p>

<p>　　6.输出所有chunk到文件系统。</p>

<p><strong>ES6模块与CommonJS模块的差异</strong></p>

<ol>
<li>CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用<br /></li>
</ol>

<p>　　2.CommonJS 模块是运行时加载，ES6模块是编译时输出接口</p>

<p>　　3.ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错</p>

<p><strong>模块加载AMD，CMD，CommonJS Modules/2.0 规范</strong></p>

<ol>
<li>这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的<br /></li>
</ol>

<p>　　2.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行</p>

<p>　　3.CMD 推崇依赖就近，AMD 推崇依赖前置</p>

<p><strong>Node 事件循环，js 事件循环差异</strong></p>

<ol>
<li>Node.js 的事件循环分为6个阶段<br /></li>
</ol>

<p>　　2.浏览器和Node 环境下，microtask 任务队列的执行时机不同</p>

<p>　　3.Node.js中，microtask 在事件循环的各个阶段之间执行</p>

<p>　　4.浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</p>

<p>　　5.递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate()</p>

<p><strong>浅拷贝和深拷贝的问题</strong></p>

<ol>
<li>深拷贝和浅拷贝是只针对Object和Array这样的复杂类型的<br /></li>
</ol>

<p>　　2.也就是说a和b指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</p>

<p>　　3.浅拷贝， ”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</p>

<p>　　4.深拷贝，JSON.parse()和JSON.stringify()给了我们一个基本的解决办法。但是函数不能被正确处理</p>

<p><strong>开放性问题</strong></p>

<p>　　开放性问题主要是考察候选人业务积累，是否有自己的思考，思考问题的方式，没有标准答案。不过有些问题挺刁钻的，哈哈哈哈，比如：&rdquo; 你见过的最好的代码是什么？ &ldquo;总之提前准备下没错。</p>

<ol>
<li>先自我介绍一下，说一下项目的技术栈，以及项目中遇到的一些问题<br /></li>
</ol>

<p>　　2.从整体中，看你对项目的认识，框架的认识和自己思考</p>

<p>　　3.项目中有没有遇到什么难点，怎么解决</p>

<p>　　4.如果你在创业公司你怎么从0开始做（选择什么框架，选择什么构建工具）</p>

<p>　　5.说一下你项目中用到的技术栈，以及觉得得意和出色的点，以及让你头疼的点，怎么解决的</p>

<p>　　6.一个业务场景，面对产品不断迭代，以及需求的变动该怎么应对，具体技术方案实现</p>

<p>　　7.你的学习来源是什么</p>

<p>　　8.你觉得哪个框架比较好，好在哪里</p>

<p>　　9.你觉得最难得技术难点是什么</p>

<p>　　10.你见过的最好的代码是什么</p>

<p>拓展阅读：<br />
<a href="http://www.itcast.cn/news/20181127/15204015463.shtml">最新Web前端开发面试题及参考答案</a><br />
<a href="http://www.itcast.cn/news/20181127/14545218540.shtml">70道web前端开发面试题（2018版含答案）</a><br />
<a href="http://www.itcast.cn/news/20181127/14361795506.shtml">传智播客整理的2018web前端开发最新面试试题（含答案）</a><br />
<a href="http://www.itcast.cn/news/20181127/14043448237.shtml">2018最新web前端面试题附答案</a><br />
<a href="http://www.itcast.cn/news/20181126/14081881664.shtml">web前端面试试题（html）（附答案）</a><br />
<a href="http://www.itcast.cn/news/20181126/13431896082.shtml">传智播客整理的web前端JavaScript面试试题（附答案）</a><br />
<a href="http://www.itcast.cn/news/20181126/13213856110.shtml">web前端面试题（汇总）</a></p>

<hr />

<p><a href="http://www.itcast.cn/news/20181127/15204015463.shtml">最新Web前端开发面试题及参考答案</a></p>

<p>　　很多企业现在要求求职者完成面试题，web前端开发面试试题已经成为web前端开发求职者求职面试过程中的重要环节之一。以下是传智播客为大家整理的：Web前端开发面试题及答案，仅供大家参考!　</p>

<p>　1、Doctype作用? 严格模式与混杂模式如何区分?它们有何意义?</p>

<p>　　(1)、声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档。</p>

<p>　　(2)、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</p>

<p>　　(3)、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>

<p>　　(4)、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p>

<p>　　2、行内元素有哪些?块级元素有哪些?</p>

<p>　　(1)CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值， 比如div默认display属性值为“block”，成为“块级”元素; span默认display属性值为“inline”，是“行内”元素。</p>

<p>　　(2)行内元素有：a b span img input select strong(强调的语气) 块级元素有：div ulol li dl dtdd h1 h2 h3 h4…p</p>

<p>　　3、link 和@import 的区别是?</p>

<p>　　(1)link属于XHTML标签，而@import是CSS提供的;</p>

<p>　　(2)页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>

<p>　　(3)import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;</p>

<p>　　(4)link方式的样式的权重高于@import的权重.</p>

<p>　　4、浏览器的内核分别是什么?</p>

<p>　　IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink(WebKit的分支)、Opera内核原为Presto，现为Blink;</p>

<p>　　5、HTML5有哪些新特性?如何处理HTML5新标签的浏览器兼容问题?如何区分 HTML 和 HTML5?</p>

<p>　　HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>

<p>　　绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation</p>

<p>　　6、对语义化如何理解?</p>

<p>　　(3)import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;</p>

<p>　　(4)link方式的样式的权重高于@import的权重.</p>

<p>　　7、浏览器的内核分别是什么?</p>

<p>　　IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink(WebKit的分支)、Opera内核原为Presto，现为Blink;</p>

<p>　　8、HTML5有哪些新特性?如何处理HTML5新标签的浏览器兼容问题?如何区分 HTML 和 HTML5?</p>

<p>　　HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>

<p>　　绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation</p>

<p>　　9、对语义化如何理解?</p>

<p>　　(3)import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;</p>

<p>　　(4)link方式的样式的权重高于@import的权重.</p>

<p>　　10、浏览器的内核分别是什么?</p>

<p>　　IE浏览器的内核Trident、Mozilla的Gecko、Chrome的Blink(WebKit的分支)、Opera内核原为Presto，现为Blink;</p>

<p>　　11、HTML5有哪些新特性?如何处理HTML5新标签的浏览器兼容问题?如何区分 HTML 和 HTML5?</p>

<p>　　HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>

<p>　　绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation</p>

<p>　　12、对语义化如何理解?</p>

<p>　　用正确的标签做正确的事情!</p>

<p>　　HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析;在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>

<p>　　13、HTML5的离线储存有几种方式?</p>

<p>　　localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage 数据在浏览器关闭后自动删除。</p>

<p>　　14、iframe有那些缺点?</p>

<p>　　iframe会阻塞主页面的Onload事件;</p>

<p>　　iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以可以绕开以上两个问题。</p>

<p>　　15、请描述一下 cookies，sessionStorage和localStorage的区别?</p>

<p>　　cookie在浏览器和服务器间来回传递。sessionStorage和localStorage不会sessionStorage和localStorage的存储空间更大;sessionStorage和</p>

<p>　　localStorage有更多丰富易用的接口;sessionStorage和localStorage各自独立的存储空间;</p>

<p>　　web前端开发面试题：CSS部分</p>

<p>　　1、CSS 选择符有哪些?哪些属性可以继承?优先级算法如何计算? CSS3新增伪类有那些?</p>

<p>　　1.id选择器( # myid) 2.类选择器(.myclassname) 3.标签选择器(div, h1, p) 4.相邻选择器(h1 + p) 5.子选择器(ul&lt; li) 6.后代选择器(li a) 7.通配符选择器( * ) 8.属性选择器(a[rel = &ldquo;external&rdquo;]) 9.伪类选择器(a: hover, li: nth - child) 可继承的样式： font-size font-family color, UL LI DL DD DT; 不可继承的样式：border padding margin width height ; 优先级就近原则，同权重情况下样式定义最近者为准;</p>

<p>　　载入样式以最后载入的定位为准;</p>

<p>　　优先级为:</p>

<p>　　!important &gt; id &gt; class &gt; tag important 比内联优先级高</p>

<p>　　2、CSS3新增伪类举例：</p>

<p>　　p:first-of-type选择属于其父元素的首个元素的每个元素。</p>

<p>　　p:last-of-type 选择属于其父元素的最后元素的每个元素。 p:only-of-type 选择属于其父元素唯一的元素的每个元素。 p:only-child 选择属于其父元素的唯一子元素的每个元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个元素。 :enabled :disabled 控制表单控件的禁用态。 :checked单选框或复选框被选中。</p>

<p>　　3、如何居中div?如何居中一个浮动元素? 给div设置一个宽度，然后添加margin:0 auto属性</p>

<p>　　div{ width:200px; margin:0 auto; }</p>

<p>　　居中一个浮动元素</p>

<p>　　确定容器的宽高宽500 高 300 的层 设置层的外边距 .div</p>

<p>　　{ Width:500px ; height:300px;//高度可以不设 Margin: -150px 0 0 -250px; position:relative;相对定位 background-color:pink;//方便看效果 left:50%; top:50%;}</p>

<p>　　列出display的值，说明他们的作用。position的值， relative和absolute定位原点是?</p>

<p>　　1.block 象块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。</p>

<p>　　2. absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p>

<p>　　fixed (老IE不支持) 生成绝对定位的元素，相对于浏览器窗口进行定位。</p>

<p>　　relative 生成相对定位的元素，相对于其正常位置进行定位。</p>

<p>　　static 默认值。没有定位，元素出现在正常的流中 *(忽略 top, bottom, left, right z-index 声明)。</p>

<p>　　inherit 规定从父元素继承 position 属性的值。</p>

<hr />

<p><a href="http://www.itcast.cn/news/20181127/14545218540.shtml">70道web前端开发面试题（2018版含答案）</a></p>

<ol>
<li><p>一个200*200的div在不同分辨率屏幕上下左右居中，用css实现</p>

<pre><code class="language-css">　　div {  
　　position:absolute;  
　　width:200px;  
　　height:200px;  
　　top:50%;  
　　left:50%;  
　　margin-left:-50px;  
　　height:-50px;  
　　z-index:1000;  
　　}
</code></pre></li>
</ol>

<p>　　2.写一个左中右布局占满屏幕，其中左右两块是固定宽度200 ，中间自适应宽，要求先加载中间块，请写出结构及样式：</p>

<p>　　<body></p>

<p>　　<h3>实现三列宽度自适应布局</h3></p>

<p>　　<divid="left">我是左边</div></p>

<p>　　<divid="right">我是右边</div></p>

<p>　　<divid="center">我是中间</div></p>

<p>　　</body></p>

<p>　　html,body{margin:0px;width:100%;}</p>

<p>　　h3{height:100px;margin:20px00;}</p>

<p>　　#left,#right{width:200px;height:200px;background-color:#ffe6b8;position:absolute;top:120px;}</p>

<p>　　#left{left:0px;}</p>

<p>　　#right{right:0px;}</p>

<p>　　#center{margin:2px210px;background-color:#eee;height:200px;}</p>

<p>　　3.阐述清楚浮动的几种方式（常见问题）</p>

<p>　　1.父级div定义 height</p>

<p>　　原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。</p>

<p>　　优点：简单、代码少、容易掌握</p>

<p>　　缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题</p>

<p>　　2.父级div定义 overflow:hidden</p>

<p>　　原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度</p>

<p>　　优点：简单、代码少、浏览器支持好</p>

<p>　　4.结尾处加空div标签 clear:both</p>

<p>　　原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度</p>

<p>　　优点：简单、代码少、浏览器支持好、不容易出现怪问题</p>

<p>　　缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好</p>

<p>　　5.解释css sprites ，如何使用？</p>

<p>　　CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。</p>

<p>　　CSS Sprites为一些大型的网站节约了带宽，让提高了用户的加载速度和用户体验，不需要加载更多的图片</p>

<p>　　6.如何用原生js给一个按钮绑定两个onclick事件？</p>

<p>　　Var btn=document.getElementById(‘btn’);</p>

<p>　　//事件监听 绑定多个事件</p>

<p>　　var btn4 = document.getElementById(&ldquo;btn4&rdquo;);</p>

<p>　　btn4.addEventListener(&ldquo;click&rdquo;,hello1);</p>

<p>　　btn4.addEventListener(&ldquo;click&rdquo;,hello2);</p>

<p>　　function hello1(){</p>

<p>　　alert(&ldquo;hello 1&rdquo;);</p>

<p>　　}</p>

<p>　　function hello2(){</p>

<p>　　alert(&ldquo;hello 2&rdquo;);</p>

<p>　　}</p>

<p>　　7.拖拽会用到哪些事件</p>

<p>　　·dragstart:拖拽开始时在被拖拽元素上触发此事件,监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件.</p>

<p>　　·dragenter:拖拽鼠标进入元素时在该元素上触发,用于给拖放元素设置视觉反馈,如高亮</p>

<p>　　·dragover:拖拽时鼠标在目标元素上移动时触发.监听器通过阻止浏览器默认行为设置元素为可拖放元素.</p>

<p>　　·dragleave:拖拽时鼠标移出目标元素时在目标元素上触发.此时监听器可以取消掉前面设置的视觉效果.</p>

<p>　　·drag:拖拽期间在被拖拽元素上连续触发</p>

<p>　　·drop:鼠标在拖放目标上释放时,在拖放目标上触发.此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.</p>

<p>　　·dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.将元素从浏览器拖放到操作系统时不会触发此事件.</p>

<p>　　8.请列举jquery中的选择器：</p>

<p>　　9.Javascript中的定时器有哪些？他们的区别及用法是什么？</p>

<p>　　setTimeout 只执行一次</p>

<p>　　setInterval 会一直重复执行</p>

<p>　　9.请描述一下 cookies sessionStorage和localstorage区别</p>

<p>　　相同点：都存储在客户端</p>

<p>　　不同点：1.存储大小</p>

<p>　　·cookie数据大小不能超过4k。</p>

<p>　　·sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>

<p>　　2.有效时间</p>

<p>　　·localStorage  存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>

<p>　　·sessionStorage 数据在当前浏览器窗口关闭后自动删除。</p>

<p>　　·cookie     设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>

<p>　　3. 数据与服务器之间的交互方式</p>

<p>　　·cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</p>

<p>　　·sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>

<p>　　10.计算一个数组arr所有元素的和</p>

<p>　　var arr1=[1,2,3,4,5,6,7,8,9];</p>

<p>　　var sum1=0;</p>

<p>　　for (var i=0;i&lt;=arr1.length;i++) {</p>

<p>　　if (typeof arr1[i]==&ldquo;number&rdquo;) {</p>

<p>　　sum1+=arr1[i];</p>

<p>　　}</p>

<p>　　}</p>

<p>　　document.write(sum1);</p>

<p>　　//====================================</p>

<p>　　functionsum2(arr){</p>

<p>　　var all=0;</p>

<p>　　for (var i=0;i&lt;arr.length;i++) {</p>

<p>　　if (typeof arr[i]==&ldquo;number&rdquo;) {</p>

<p>　　all+=arr[i];</p>

<p>　　}</p>

<p>　　}</p>

<p>　　returnall;</p>

<p>　　}</p>

<p>　　document.write(sum2([1,2,3,4]));</p>

<p>　　11.编写一个方法去掉数组里面 重复的内容 var arr=[1,2,3,4,5,1,2,3]</p>

<p>　　一个数组去重的简单实现</p>

<p>　　var arr = [&lsquo;abc&rsquo;,&lsquo;abcd&rsquo;,&lsquo;sss&rsquo;,&lsquo;2&rsquo;,&rsquo;d&rsquo;,&rsquo;t&rsquo;,&lsquo;2&rsquo;,&lsquo;ss&rsquo;,&lsquo;f&rsquo;,&lsquo;22&rsquo;,&rsquo;d&rsquo;];</p>

<p>　　//定义一个新的数组</p>

<p>　　var s = [];</p>

<p>　　//遍历数组</p>

<p>　　for(var i = 0;i&lt;arr.length;i++){</p>

<p>　　if(s.indexOf(arr[i]) == -1){ //判断在s数组中是否存在，不存在则push到s数组中</p>

<p>　　s.push(arr[i]);</p>

<p>　　}</p>

<p>　　}</p>

<p>　　console.log(s);</p>

<p>　　//输出结果：[&ldquo;abc&rdquo;, &ldquo;abcd&rdquo;, &ldquo;sss&rdquo;, &ldquo;2&rdquo;, &ldquo;d&rdquo;, &ldquo;t&rdquo;, &ldquo;ss&rdquo;, &ldquo;f&rdquo;, &ldquo;22&rdquo;]</p>

<p>　　方法二：用sort() 然后相邻比较也可以实现</p>

<p>　　12.document.write和innerHTML的区别：</p>

<p>　　document.write是直接写入到页面的内容流，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。</p>

<p>　　innerHTML则是DOM页面元素的一个属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改document.documentElement.innerElement。</p>

<p>　　innerHTML将内容写入某个DOM节点，不会导致页面全部重绘</p>

<p>　　innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。</p>

<p>　　13.ajax的步骤</p>

<p>　　什么是ajax</p>

<p>　　ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页。</p>

<p>　　如何使用ajax</p>

<p>　　第一步，创建xmlhttprequest对象，var xmlhttp =new XMLHttpRequest（);XMLHttpRequest对象用来和服务器交换数据。</p>

<p>　　var xhttp;</p>

<p>　　if (window.XMLHttpRequest) {</p>

<p>　　//现代主流浏览器</p>

<p>　　xhttp = new XMLHttpRequest();</p>

<p>　　} else {</p>

<p>　　// 针对浏览器，比如IE5或IE6</p>

<p>　　xhttp = new ActiveXObject(&ldquo;Microsoft.XMLHTTP&rdquo;);</p>

<p>　　}</p>

<p>　　第二步，使用xmlhttprequest对象的open（）和send（）方法发送资源请求给服务器。</p>

<p>　　第三步，使用xmlhttprequest对象的responseText或responseXML属性获得服务器的响应。</p>

<p>　　第四步，onreadystatechange函数，当发送请求到服务器，我们想要服务器响应执行一些功能就需要使用onreadystatechange函数，每次xmlhttprequest对象的readyState发生改变都会触发onreadystatechange函数</p>

<p>　　14.xml和json的区别，请用四个词语来形容</p>

<p>　　·JSON相对于XML来讲，数据的体积小，传递的速度更快些</p>

<p>　　·JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</p>

<p>　　·XML对数据描述性比较好；</p>

<p>　　·JSON的速度要远远快于XML</p>

<p>　　15.清楚浮动的方法？(多次出现在面试题)</p>

<p>　　1.父级div定义 height</p>

<p>　　原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。</p>

<p>　　优点：简单、代码少、容易掌握</p>

<p>　　缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题</p>

<p>　　2，结尾处加空div标签 clear:both</p>

<p>　　原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度</p>

<p>　　优点：简单、代码少、浏览器支持好、不容易出现怪问题</p>

<p>　　缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好</p>

<p>　　3，父级div定义 伪类:after 和 zoom</p>

<p>　　原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题</p>

<p>　　优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）</p>

<p>　　缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持</p>

<p>　　4，父级div定义 overflow:hidden</p>

<p>　　原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度</p>

<p>　　优点：简单、代码少、浏览器支持好</p>

<p>　　缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。</p>

<p>　　16.box-sizing常用的属性有哪些？分别有什么作用？</p>

<p>　　属性值</p>

<p>　　·box-sizing：content-box</p>

<p>　　·box-sizing：border-box</p>

<p>　　·box-sizing：inherit</p>

<p>　　content-box</p>

<p>　　·这是box-sizing的默认属性值</p>

<p>　　·是CSS2.1中规定的宽度高度的显示行为</p>

<p>　　·在CSS中定义的宽度和高度就对应到元素的内容框</p>

<p>　　·在CSS中定义的宽度和高度之外绘制元素的内边距和边框</p>

<p>　　border-box</p>

<p>　　·在CSS中微元素设定的宽度和高度就决定了元素的边框盒</p>

<p>　　·即为元素在设置内边距和边框是在已经设定好的宽度和高度之内进行绘制</p>

<p>　　·CSS中设定的宽度和高度减去边框和内间距才能得到元素内容所占的实际宽度和高度</p>

<p>　　(Q1)box-sizing: content-box|border-box|inherit;</p>

<p>　　(Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。</p>

<p>　　border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</p>

<p>　　17.css选择器有哪些，选择器的权重的优先级</p>

<p>　　选择器类型</p>

<p>　　1、ID　　#id</p>

<p>　　2、class　　.class</p>

<p>　　3、标签　　p</p>

<p>　　4、通用　　*</p>

<p>　　5、属性　　[type=&ldquo;text&rdquo;]</p>

<p>　　6、伪类　　：hover</p>

<p>　　7、伪元素　　::first-line</p>

<p>　　8、子选择器、相邻选择器</p>

<p>　　三、权重计算规则</p>

<p>　　1.第一等：代表内联样式，如: style=””，权值为1000。</p>

<p>　　2.第二等：代表ID选择器，如：#content，权值为0100。</p>

<p>　　3.第三等：代表类，伪类和属性选择器，如.content，权值为0010。</p>

<p>　　4.第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。</p>

<p>　　5.通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。</p>

<p>　　6.继承的样式没有权值。</p>

<p>　　18.块级元素水平垂直居中的方法有哪些（三个方法）</p>

<p>　　让div等块级元素水平和垂直都居中，即永远处于屏幕的正中央，当我们做如登录块时非常有用！</p>

<p>　　实现一、原理：要让div等块级元素水平和垂直居中，必需知道该div等块级元素的宽度和高度，然后设置位置为绝对位置，距离页面窗口左边框和上边框的距离设置为50%，这个50%就是指页面窗口的宽度和高度的50%，最后将该div等块级元素分别左移和上移，左移和上移的大小就是该div等块级元素宽度和高度的一半。</p>

<p>　　CSS代码：</p>

<p>　　.mycss{</p>

<p>　　width:300px;</p>

<p>　　height:200px;</p>

<p>　　position:absolute;</p>

<p>　　left:50%;</p>

<p>　　top:50%;</p>

<p>　　margin:-100px 0 0 -150px }</p>

<p>　　实现二原理：利用CSS的margin设置为auto让浏览器自己帮我们水平和垂直居中。</p>

<p>　　CSS代码：</p>

<p>　　.mycss{</p>

<p>　　position:absolute;</p>

<p>　　left:0px;</p>

<p>　　right:0;</p>

<p>　　top:0;</p>

<p>　　bottom:0;</p>

<p>　　margin:auto;</p>

<p>　　height:200px;</p>

<p>　　width:300px;</p>

<p>　　}</p>

<p>　　jQuery实现水平和垂直居中</p>

<p>　　原理：jQuery实现水平和垂直居中的原理就是通过jQuery设置div等块级元素的CSS，获取div等块级元素的左、上的边距偏移量，边距偏移量的算法就是用页面窗口 的宽度减去该div等块级元素的宽度，得到的值再除以2即左偏移量，右偏移量算法相同。注意div等块级元素的CSS设置要在resize()方法中完成，就是每次改变窗口大 小时，都要执行设置div等块级元素的CSS。</p>

<p>　　jquery代码：</p>

<p>　　$(window).resize(function(){</p>

<p>　　$(&ldquo;.myblock&rdquo;).css({</p>

<p>　　position: &ldquo;absolute&rdquo;,</p>

<p>　　left: ($(window).width() - $(&ldquo;.myblock&rdquo;).outerWidth())/2,</p>

<p>　　top: ($(window).height() - $(&ldquo;.myblock&rdquo;).outerHeight())/2 });</p>

<p>　　});</p>

<p>　　此外在页面载入时，就需要调用resize()方法</p>

<p>　　$(function(){</p>

<p>　　$(window).resize();</p>

<p>　　});</p>

<p>　　19.三个盒子，左右定宽，中间自适应有几种方法</p>

<p>　　第一种：左右侧采用浮动 中间采用margin-left 和 margin-right 方法。</p>

<p>　　代码如下：</p>

<p>　　<div style="width:100%; margin:0 auto;"></p>

<p>　　<div style="width:200px; float:right; background-color:#960">这是右侧的内容 固定宽度</div></p>

<p>　　<div style="width:150px; float:left; background:#6FF">这是左侧的内容 固定宽度</div></p>

<p>　　<div style="margin-left:150px;margin-right:200px; background-color:#9F3">中间内容，自适应宽度</div></p>

<p>　　</div></p>

<p>　　第二种：左右两侧采用绝对定位中间同样采用margin-left margin-right方法：</p>

<p>　　第三种负的margin</p>

<p>　　使用这种方法就稍微复杂了一些了，使用的是负的margin值，而且html标签也增加了，先来看其代码吧：</p>

<p>　　<div id="main"></p>

<p>　　<div id="mainContainer">main content</div></div><div id="left"></p>

<p>　　<div id="leftContainer"class="inner">left content</div></div><div id="right"></p>

<p>　　<div id="rightContainer"class="inner">right</div></div></p>

<p>　　#main {</p>

<p>　　float:left;</p>

<p>　　width:100%;</p>

<p>　　}</p>

<p>　　#mainContainer {</p>

<p>　　margin:0 230px;</p>

<p>　　height:200px;</p>

<p>　　background:green;</p>

<p>　　}</p>

<p>　　#left {</p>

<p>　　float:left;</p>

<p>　　margin-left:-100%;</p>

<p>　　width:230px}</p>

<p>　　#right {</p>

<p>　　float:left;</p>

<p>　　margin-left:-230px;</p>

<p>　　width:230px;</p>

<p>　　}</p>

<p>　　#left .inner,</p>

<p>　　#right .inner {</p>

<p>　　background:orange;</p>

<p>　　margin:0 10px;</p>

<p>　　height:200px;</p>

<p>　　}</p>

<p>　　20.js有几种数据类型，其中基本数据类型有哪些</p>

<p>　　五种基本类型:Undefined、Null、Boolean、Number和String。</p>

<p>　　1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。</p>

<p>　　Object、Array和Function则属于引用类型</p>

<p>　　21.undefined 和 null 区别</p>

<p>　　null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。</p>

<p>　　undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。</p>

<p>　　null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。</p>

<p>　　javaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。</p>

<p>　　22.http 和 https 有何区别？如何灵活使用？</p>

<p>　　http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p>

<p>　　https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</p>

<p>　　23.常见的HTTP状态码</p>

<p>　　2开头 （请求成功）表示成功处理了请求的状态代码。</p>

<p>　　200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p>

<p>　　201 （已创建） 请求成功并且服务器创建了新的资源。</p>

<p>　　202 （已接受） 服务器已接受请求，但尚未处理。</p>

<p>　　203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p>

<p>　　204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</p>

<p>　　205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</p>

<p>　　206 （部分内容） 服务器成功处理了部分 GET 请求。</p>

<p>　　3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>

<p>　　300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p>

<p>　　301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p>

<p>　　302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>

<p>　　303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p>

<p>　　304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p>

<p>　　305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p>

<p>　　307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>

<p>　　4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>

<p>　　400 （错误请求） 服务器不理解请求的语法。</p>

<p>　　401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p>

<p>　　403 （禁止） 服务器拒绝请求。</p>

<p>　　404 （未找到） 服务器找不到请求的网页。</p>

<p>　　405 （方法禁用） 禁用请求中指定的方法。</p>

<p>　　406 （不接受） 无法使用请求的内容特性响应请求的网页。</p>

<p>　　407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p>

<p>　　408 （请求超时） 服务器等候请求时发生超时。</p>

<p>　　409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p>

<p>　　410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</p>

<p>　　411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</p>

<p>　　412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</p>

<p>　　413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p>

<p>　　414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</p>

<p>　　415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</p>

<p>　　416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p>

<p>　　417 （未满足期望值） 服务器未满足&rdquo;期望&rdquo;请求标头字段的要求。</p>

<p>　　5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>

<p>　　500 （服务器内部错误） 服务器遇到错误，无法完成请求。</p>

<p>　　501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p>

<p>　　502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p>

<p>　　503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p>

<p>　　504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p>

<p>　　505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>

<p>　　24.如何进行网站性能优化</p>

<p>　　1. 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</p>

<p>　　2. 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</p>

<p>　　总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。</p>

<p>　　前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。</p>

<p>　　一、页面级优化</p>

<p>　　1. JavaScript 压缩和模块打包</p>

<p>　　2. 按需加载资源</p>

<p>　　3. 在使用 DOM 操作库时用上 array-ids</p>

<p>　　4. 缓存</p>

<p>　　5. 启用 HTTP/2</p>

<p>　　6. 应用性能分析</p>

<p>　　7. 使用负载均衡方案</p>

<p>　　8. 为了更快的启动时间考虑一下同构</p>

<p>　　9. 使用索引加速数据库查询</p>

<p>　　10. 使用更快的转译方案</p>

<p>　　11. 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染</p>

<p>　　12. 用于未来的一个建议：使用 service workers + 流</p>

<p>　　13. 图片编码优化</p>

<p>　　25.react和vue有哪些不同，说说你对这两个框架的看法</p>

<p>　　相同点</p>

<p>　　·都支持服务器端渲染</p>

<p>　　·都有Virtual DOM,组件化开发,通过props参数进行父子组件数据的传递,都实现webComponent规范</p>

<p>　　·数据驱动视图</p>

<p>　　·都有支持native的方案,React的React native,Vue的weex</p>

<p>　　不同点</p>

<p>　　·React严格上只针对MVC的view层,Vue则是MVVM模式</p>

<p>　　·virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</p>

<p>　　·组件写法不一样, React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即&rsquo;all in js&rsquo;; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,jd写在同一个文件;</p>

<p>　　·数据绑定: vue实现了数据的双向绑定,react数据流动是单向的</p>

<p>　　·state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理</p>

<p>　　26.什么是mvvm mvc是什么区别 原理</p>

<p>　　一、MVC（Model-View-Controller）</p>

<p>　　MVC是比较直观的架构模式，用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。</p>

<p>　　MVC使用非常广泛，比如JavaEE中的SSH框架</p>

<p>　　三、MVVM（Model-View-ViewModel）</p>

<p>　　如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应view。</p>

<p>　　27.px和em的区别</p>

<p>　　px表示像素 (计算机屏幕上的一个点：1px = 1/96in)，是绝对单位，不会因为其他元素的尺寸变化而变化；</p>

<p>　　·</p>

<p>　　·</p>

<p>　　em表示相对于父元素的字体大小。em是相对单位 ，没有一个固定的度量值，而是由其他元素尺寸来决定的相对值。</p>

<p>　　28.优雅降级和渐进增强</p>

<p>　　渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p>

<p>　　优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p>

<p>　　其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容</p>

<p>　　29.eval()的作用</p>

<p>　　把字符串参数解析成JS代码并运行，并返回执行的结果；</p>

<p>　　eval(&ldquo;2+3&rdquo;);//执行加运算，并返回运算值。</p>

<p>　　eval(&ldquo;varage=10&rdquo;);//声明一个age变量</p>

<p>　　eval的作用域</p>

<p>　　functiona(){</p>

<p>　　1.eval(&ldquo;varx=1&rdquo;);//等效于varx=1;</p>

<p>　　2.console.log(x);//输出1</p>

<p>　　3.}</p>

<p>　　4.a();</p>

<p>　　5.console.log(x);//错误x没有定</p>

<p>　　30.JS哪些操作会造成内存泄露</p>

<p>　　1）意外的全局变量引起的内存泄露</p>

<p>　　functionleak(){</p>

<p>　　leak=&ldquo;xxx&rdquo;;//leak成为一个全局变量，不会被回收</p>

<p>　　}</p>

<p>　　2）闭包引起的内存泄露</p>

<p>　　3）3）没有清理的DOM元素引用</p>

<p>　　4）被遗忘的定时器或者回调5）子元素存在引起的内存泄露</p>

<p>　　31.浏览器缓存有哪些，通常缓存有哪几种</p>

<p>　　一、http缓存</p>

<p>　　二、websql</p>

<p>　　cookie</p>

<p>　　localstorage</p>

<p>　　sessionstorage</p>

<p>　　flash缓存</p>

<p>　　32:bootstrap响应式实现的原理</p>

<p>　　百分比布局+媒体查询</p>

<p>　　33.关于JS事件冒泡与JS事件代理（事件委托）</p>

<p>　　事件作为DOM操作重要的一环，需要大家好好理解和运用，今天特意看了一下事件冒泡和事件代理的相关资料，感触颇深，也深感自己的无知不知道多浪费了多少内存，废话不多说进入正题：</p>

<p>　　1.事件冒泡：</p>

<p>　　通俗易懂的来讲，就是当一个子元素的事件被触发的时候（如onclick事件），该事件会从事件源（被点击的子元素）开始逐级向上传播，触发父级元素的点击事件。</p>

<p>　　2.事件委托</p>

<p>　　事件委托，首先按字面的意思就能看你出来，是将事件交由别人来执行，再联想到上面讲的事件冒泡，是不是想到了？对，就是将子元素的事件通过冒泡的形式交由父元素来执行。下面经过详细的例子来说明事件委托：</p>

<p>　　有可能在开发的时候会遇到这种情况：如导航每一个栏目都要加一个事件，你可能会通过遍历来给每个栏目添加事件：</p>

<p>　　事件委托是怎</p>

<p>　　1.varul=document.getElementById(&lsquo;parentUl&rsquo;);</p>

<p>　　2.ul.onclick=function(event){</p>

<p>　　3.vare=event||window.event,</p>

<p>　　4.source=e.target||e.srcElement;//target表示在事件冒泡中触发事件的源元素，在IE中是srcElement</p>

<p>　　5.if(source.nodeName.toLowerCase()==&ldquo;li&rdquo;){//判断只有li触发的才会输出内容</p>

<p>　　6.alert(source.innerHTML);</p>

<p>　　7.}</p>

<p>　　8.stopPropagation(e);//阻止继续冒泡</p>

<p>　　9.};</p>

<p>　　10.functionaddElement(){</p>

<p>　　11.varli=document.createElement(&lsquo;li&rsquo;);</p>

<p>　　12.li.innerHTML=&ldquo;我是新孩子&rdquo;;</p>

<p>　　13.ul.appendChild(li);</p>

<p>　　14.}</p>

<p>　　34.CSS样式覆盖规则</p>

<p>　　规则一：由于继承而发生样式冲突时，最近祖先获胜。</p>

<p>　　规则二：继承的样式和直接指定的样式冲突时，直接指定的样式获胜</p>

<p>　　规则三：直接指定的样式发生冲突时，样式权值高者获胜。</p>

<p>　　样式的权值取决于样式的选择器，权值定义如下表。</p>

<p>　　CSS选择器权值</p>

<p>　　标签选择器1</p>

<p>　　类选择器10</p>

<p>　　ID选择器100</p>

<p>　　内联样式1000</p>

<p>　　伪元素(:first-child等)1</p>

<p>　　伪类(:link等)10</p>

<p>　　可以看到，内联样式的权值&gt;&gt;ID选择器&gt;&gt;类选择器&gt;&gt;标签选择器，除此以外，后代选择器的权值为每项权值之和，比如”#nav .current a”的权值为100 + 10 + 1 = 111。</p>

<p>　　规则四：样式权值相同时，后者获胜。</p>

<p>　　规则五：!important的样式属性不被覆盖。</p>

<p>　　!important可以看做是万不得已的时候，打破上述四个规则的”金手指”。如果你一定要采用某个样式属性，而不让它被覆盖的，可以在属性值后加上!important，以规则四的例子为例，”.byline a {color:red !important;}”可以强行使链接显示红色。大多数情况下都可以通过其他方式来控制样式的覆盖，不能滥用!important。</p>

<p>　　35.介绍一下box-sizing属性</p>

<p>　　兼容问题</p>

<p>　　首先，box-sizing属性在FireFox中存在兼容问题，所以需要使用-moz-box-sizing做一下兼容。</p>

<p>　　属性值</p>

<p>　　·box-sizing：content-box</p>

<p>　　·box-sizing：border-box</p>

<p>　　·box-sizing：inherit</p>

<p>　　content-box</p>

<p>　　·这是box-sizing的默认属性值</p>

<p>　　·是CSS2.1中规定的宽度高度的显示行为</p>

<p>　　·在CSS中定义的宽度和高度就对应到元素的内容框</p>

<p>　　·在CSS中定义的宽度和高度之外绘制元素的内边距和边框</p>

<p>　　border-box</p>

<p>　　·在CSS中微元素设定的宽度和高度就决定了元素的边框盒</p>

<p>　　·即为元素在设置内边距和边框是在已经设定好的宽度和高度之内进行绘制</p>

<p>　　·CSS中设定的宽度和高度减去边框和内间距才能得到元素内容所占的实际宽度和高度</p>

<p>　　36.css选择符有哪些？优先级算法如何计算？（常见）</p>

<p>　　37.请简要描述margin重合问题，及解决方式</p>

<p>　　1.同向margin的重叠：</p>

<p>　　1图片的margin-top与3图片的margin-top发生重叠，2图片的margin-bottom与3图片的margin-bottom发生重叠。这时候重叠之后的margin值由发生重叠两片的最大值决定；如果其中一个出现负值，则由最大的正边距减去绝对值最大的负边距，如果没有最大正边距，则由0减去绝对值最大的负边距。</p>

<p>　　解决同向重叠的方法：</p>

<p>　　（1）在最外层的div中加入overflow:hidden;zoom:1</p>

<p>　　（2）在最外层加入padding:1px;属性</p>

<p>　　（3）在最外层加入：border:1px solid #cacbcc;</p>

<p>　　2.异向重叠问题：</p>

<p>　　1图片的margin-bottom与2图片的margin-top发生重叠，这时候重叠之后的margin值由发生重叠两图片的最大值的决定的。</p>

<p>　　解决异向重叠问题：</p>

<p>　　float:left（只能解决IE6浏览器中的异向重叠问题，可以解决IE8以上、chorme、firefox、opera下的同向重叠问题）</p>

<p>　　38：position的值，relative\absolute\fixed分别相对于进行谁定位，有什么区别，什么时候用？</p>

<p>　　39.解释下CSSsprites，以及你要如何在页面或网站中使用它。</p>

<p>　　CSSSprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background-repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置</p>

<p>　　40.什么是闭包，如何使用它，为什么要使用它？</p>

<p>　　包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>

<p>　　所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>

<p>　　使用闭包的注意点：</p>

<p>　　·由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>

<p>　　·闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（PublicMethod），把内部变量当作它的私有属性（privatevalue），这时一定要小心，不要随便改变父函数内部变量的值。</p>

<p>　　41.请解释JSONP的工作原理，以及它为什么不是真正的AJAX。</p>

<p>　　JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>

<p>　　AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</p>

<p>　　42.请解释一下JavaScript的同源策略。</p>

<p>　　在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>

<p>　　43.怎样添加、移除、移动、复制、创建和查找节点？</p>

<p>　　1）创建新节点</p>

<p>　　createDocumentFragment() //创建一个DOM片段</p>

<p>　　createElement() //创建一个具体的元素</p>

<p>　　createTextNode() //创建一个文本节点</p>

<p>　　2）添加、移除、替换、插入</p>

<p>　　appendChild() //添加</p>

<p>　　removeChild() //移除</p>

<p>　　replaceChild() //替换</p>

<p>　　insertBefore() //插入</p>

<p>　　3）查找</p>

<p>　　getElementsByTagName() //通过标签名称</p>

<p>　　getElementsByName() //通过元素的Name属性的值</p>

<p>　　getElementById() //通过元素Id，唯一性</p>

<p>　　44.谈谈垃圾回收机制方式及内存管理</p>

<p>　　回收机制方式</p>

<p>　　1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</p>

<p>　　2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>

<p>　　3、实例如下：</p>

<p>　　function fn1() {</p>

<p>　　varobj = {name: &lsquo;hanzichi&rsquo;, age: 10};</p>

<p>　　}</p>

<p>　　function fn2() {</p>

<p>　　varobj = {name:&lsquo;hanzichi&rsquo;, age: 10};</p>

<p>　　returnobj;</p>

<p>　　}vara = fn1();varb = fn2();</p>

<p>　　fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</p>

<p>　　4、垃圾回收策略：标记清除(较为常用)和引用计数。</p>

<p>　　标记清除：</p>

<p>　　定义和用法：当变量进入环境时，将变量标记&rdquo;进入环境&rdquo;，当变量离开环境时，标记为：&rdquo;离开环境&rdquo;。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</p>

<p>　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>

<p>　　引用计数：</p>

<p>　　定义和用法：引用计数是跟踪记录每个值被引用的次数。</p>

<p>　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p>

<p>　　45、jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？</p>

<p>　　(1)、bind 【jQuery 1.3之前】</p>

<p>　　定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；</p>

<p>　　语法：bind(type,[data],function(eventObject))；</p>

<p>　　特点：</p>

<p>　　(1)、适用于页面元素静态绑定。只能给调用它的时候已经存在的元素绑定事件，不能给未来新增的元素绑定事件。</p>

<p>　　(2)、当页面加载完的时候，你才可以进行bind()，所以可能产生效率问题。</p>

<p>　　实例如下：$( &ldquo;#members li a&rdquo; ).bind( &ldquo;click&rdquo;, function( e ) {} );</p>

<p>　　(2)、live 【jQuery 1.3之后】</p>

<p>　　定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；</p>

<p>　　语法：live(type, [data], fn);</p>

<p>　　特点：</p>

<p>　　(1)、live方法并没有将监听器绑定到自己(this)身上，而是绑定到了this.context上了。</p>

<p>　　(2)、live正是利用了事件委托机制来完成事件的监听处理，把节点的处理委托给了document，新添加的元素不必再绑定一次监听器。</p>

<p>　　(3)、使用live（）方法但却只能放在直接选择的元素后面，不能在层级比较深，连缀的DOM遍历方法后面使用，即$(“ul”&rdquo;).live&hellip;可以，但$(&ldquo;body&rdquo;).find(&ldquo;ul&rdquo;).live&hellip;不行；</p>

<p>　　实例如下：$( document ).on( &ldquo;click&rdquo;, &ldquo;#members li a&rdquo;, function( e ) {} );</p>

<p>　　(3)、delegate 【jQuery 1.4.2中引入】</p>

<p>　　定义和用法：将监听事件绑定在就近的父级元素上</p>

<p>　　语法：delegate(selector,type,[data],fn)</p>

<p>　　特点：</p>

<p>　　(1)、选择就近的父级元素，因为事件可以更快的冒泡上去，能够在第一时间进行处理。</p>

<p>　　(2)、更精确的小范围使用事件代理，性能优于.live()。可以用在动态添加的元素上。</p>

<p>　　实例如下：</p>

<p>　　$(&ldquo;#info_table&rdquo;).delegate(&ldquo;td&rdquo;,&ldquo;click&rdquo;,function(){/<em>显示更多信息</em>/});</p>

<p>　　$(&ldquo;table&rdquo;).find(&ldquo;#info&rdquo;).delegate(&ldquo;td&rdquo;,&ldquo;click&rdquo;,function(){/<em>显示更多信息</em>/});</p>

<p>　　(4)、on 【1.7版本整合了之前的三种方式的新事件绑定机制】</p>

<p>　　定义和用法：将监听事件绑定到指定元素上。</p>

<p>　　语法：on(type,[selector],[data],fn)</p>

<p>　　实例如下：$(&ldquo;#info_table&rdquo;).on(&ldquo;click&rdquo;,&ldquo;td&rdquo;,function(){/<em>显示更多信息</em>/});参数的位置写法与delegate不一样。</p>

<p>　　说明：on方法是当前JQuery推荐使用的事件绑定方法，附加只运行一次就删除函数的方法是one()。</p>

<p>　　总结：.bind(), .live(), .delegate(),.on()分别对应的相反事件为：.unbind(),.die(), .undelegate(),.off()</p>

<p>　　46、px和em的区别</p>

<p>　　相同点：px和em都是长度单位；</p>

<p>　　异同点：px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。</p>

<p>　　浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。</p>

<p>　　47、浏览器的内核分别是什么</p>

<p>　　IE: trident内核</p>

<p>　　Firefox：gecko内核</p>

<p>　　Safari：webkit内核</p>

<p>　　Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核</p>

<p>　　Chrome：Blink(基于webkit，Google与Opera Software共同开发)</p>

<p>　　48、什么叫优雅降级和渐进增强？</p>

<p>　　渐进增强 progressive enhancement：</p>

<p>　　针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>

<p>　　优雅降级 graceful degradation：</p>

<p>　　一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>

<p>　　区别：</p>

<p>　　a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给</p>

<p>　　b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p>

<p>　　c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>

<p>　　49、sessionStorage 、localStorage 和cookie 之间的区别</p>

<p>　　共同点：用于浏览器端存储的缓存数据</p>

<p>　　不同点：</p>

<p>　　(1)、存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；</p>

<p>　　web storage,会将数据保存到本地，不会造成宽带浪费；</p>

<p>　　(2)、数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;</p>

<p>　　(3)、数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器；</p>

<p>　　sessionStorage,仅在关闭浏览器之前有效；localStorage,数据存储永久有效；</p>

<p>　　(4)、作用域不同：cookie和localStorage是在同源同窗口中都是共享的；sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</p>

<p>　　50、浏览器是如何渲染页面的？</p>

<p>　　渲染的流程如下：</p>

<p>　　1.解析HTML文件，创建DOM树。</p>

<p>　　自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。</p>

<p>　　2.解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式；</p>

<p>　　3.将CSS与DOM合并，构建渲染树（Render Tree）</p>

<p>　　4.布局和绘制，重绘（repaint）和重排（reflow）</p>

<p>　　51:js的基本数据类型</p>

<p>　　JavaScript中有五种基本数据类型，它们分别是：undefined，null，boolean，number，string。</p>

<p>　　还有一种复杂数据类型-object。</p>

<p>　　52：事件委托</p>

<p>　　事件委托就是利用的DOM事件的事件捕获阶段。把具体dom上发生的事件，委托给更大范围的dom去处理。好比送信员，如果每次都把信件送给每一户，非常繁琐。但是如果交给一个大范围的管理者，比如小区的传达室，那么事情会变得非常简单。事件委托就类似这种原理，我页面中有很多按钮，如果不使用事件委托，我只能在每个按钮上注册事件。非常麻烦。但如果我把事件注册在一个大范围的div（假设所有的按钮都在这个div中），那么我只要注册一次事件，就可以处理所有按钮（只要按钮包含在上述div中）事件的响应了</p>

<p>　　53：CSS3新增了很多的属性，下面一起来分析一下新增的一些属性：</p>

<p>　　1.CSS3边框：</p>

<p>　　·border-radius：CSS3圆角边框。在 CSS2 中添加圆角矩形需要技巧，我们必须为每个圆角使用不同的图片，在 CSS3 中，创建圆角是非常容易的，在 CSS3 中，border-radius 属性用于创建圆角。border：2px solid;</p>

<p>　　·box-shadow：CSS3边框阴影。在 CSS3 中，box-shadow 用于向方框添加阴影。box-shadow:10px 10px 5px #888888;</p>

<p>　　·border-image：CSS3边框图片。通过 CSS3 的 border-image 属性，您可以使用图片来创建边框。border-image：url(border.png) 30 30 round;</p>

<p>　　2.CSS3背景：</p>

<p>　　·background-size： 属性规定背景图片的尺寸。在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。</p>

<p>　　·background-origin ：属性规定背景图片的定位区域。背景图片可以放置于 content-box、padding-box 或 border-box 区域。</p>

<p>　　3.CSS3文字效果：</p>

<p>　　·text-shadow：在 CSS3 中，text-shadow 可向文本应用阴影。text-shadow:5px 5px 5px #FFFFFF;</p>

<p>　　·word-wrap :单词太长的话就可能无法超出某个区域，允许对长单词进行拆分，并换行到下一行：p{word-wrap:break-word;}</p>

<p>　　4.CSS3 2D转换：</p>

<p>　　transform：通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。</p>

<p>　　·translate()：元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数：transform：translate（50px,100px）;值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。</p>

<p>　　·rotate()：元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。transform:rotate(30deg);值 rotate(30deg) 把元素顺时针旋转 30 度。</p>

<p>　　·scale():元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数：transform:scale(2,4);值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高x() 5.CSS3 3D转换：</p>

<p>　　·rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform：rotateX(120deg);</p>

<p>　　·rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform：rotateY(120deg);</p>

<p>　　6.CSS3 过渡：当元素从一种样式变换为另一种样式时为元素添加效果。</p>

<p>　　7.CSS3动画：通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。</p>

<p>　　8.CSS3多列：</p>

<p>　　·column-count：属性规定元素应该被分隔的列数。</p>

<p>　　·column-gap：属性规定列之间的间隔。</p>

<p>　　·column-rule ：属性设置列之间的宽度、样式和颜色规则。</p>

<p>　　9.CSS3用户界面：</p>

<p>　　·resize：属性规定是否可由用户调整元素尺寸。</p>

<p>　　·box-sizing：属性允许您以确切的方式定义适应某个区域的具体内容。</p>

<p>　　·outline-offset ：属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p>

<p>　　54：从输入url到显示页面，都经历了什么</p>

<p>　　第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器。</p>

<p>　　第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回。</p>

<p>　　第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址。</p>

<p>　　第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址。</p>

<p>　　第五步：重复第四步,直到找到正确的纪录。</p>

<p>　　第2种解释：</p>

<p>　　一般会经历以下几个过程：</p>

<p>　　1、首先，在浏览器地址栏中输入url</p>

<p>　　2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。</p>

<p>　　3、在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。</p>

<p>　　4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）</p>

<p>　　5、握手成功后，浏览器向服务器发送http请求，请求数据包。</p>

<p>　　6、服务器处理收到的请求，将数据返回至浏览器</p>

<p>　　7、浏览器收到HTTP响应</p>

<p>　　8、读取页面内容，浏览器渲染，解析html源码</p>

<p>　　9、生成Dom树、解析css样式、js交互</p>

<p>　　10、客户端和服务器交互</p>

<p>　　11、ajax查询</p>

<p>　　55：对<meta></meta>标签有什么理解</p>

<p>　　什么是meta标签？</p>

<p>　　引自下W3school的定义说明一下。</p>

<p>　　元数据（metadata）是关于数据的信息。</p>

<p>　　标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。</p>

<p>　　典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。</p>

<p>　　标签始终位于 head 元素中。</p>

<p>　　元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>

<p>　　其实对上面的概念简单总结下就是：<meta>标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>

<p>　　meta的作用</p>

<p>　　meta里的数据是供机器解读的，告诉机器该如何解析这个页面，还有一个用途是可以添加服务器发送到浏览器的http头部内容</p>

<p>　　56：new操作符到底到了什么</p>

<p>　　先看代码</p>

<p>　　[javascript]view plaincopy</p>

<p>　　1.varFunc=function(){</p>

<p>　　2.};</p>

<p>　　3.varfunc=newFunc();</p>

<p>　　new共经过了4几个阶段</p>

<p>　　1、创建一个空对象</p>

<p>　　[javascript]view plaincopy</p>

<p>　　1.varobj=newObject();</p>

<p>　　2、设置原型链</p>

<p>　　[javascript]view plaincopy</p>

<p>　　1.obj.<strong>proto</strong>=Func.prototype;</p>

<p>　　3、让Func中的this指向obj，并执行Func的函数体。</p>

<p>　　[javascript]view plaincopy</p>

<p>　　1.varresult=Func.call(obj);</p>

<p>　　4、判断Func的返回值类型：</p>

<p>　　如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。</p>

<p>　　[javascript]view plaincopy</p>

<p>　　1.if(typeof(result)==&ldquo;object&rdquo;){</p>

<p>　　2.func=result;</p>

<p>　　3.}</p>

<p>　　4.else{</p>

<p>　　5.func=obj;;</p>

<p>　　6.}</p>

<p>　　57：h5新特性</p>

<p>　　HTML5新特性 —— 新特性</p>

<p>　　(1)新的语义标签和属性</p>

<p>　　(2)表单新特性</p>

<p>　　(3)视频和音频</p>

<p>　　(4)Canvas绘图</p>

<p>　　(5)SVG绘图</p>

<p>　　(6)地理定位</p>

<p>　　(7)拖放API</p>

<p>　　58：vue的生命周期</p>

<p>　　58：请写出你对闭包的理解，并列出简单的理解</p>

<p>　　使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>

<p>　　闭包有三个特性：</p>

<p>　　1.函数嵌套函数</p>

<p>　　2.函数内部可以引用外部的参数和变量</p>

<p>　　3.参数和变量不会被垃圾回收机制回收</p>

<p>　　59：display none visibility hidden区别？</p>

<p>　　1.display:none是彻底消失，不在文档流中占位，浏览器也不会解析该元素；visibility:hidden是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；</p>

<p>　　2.使用visibility:hidden比display:none性能上要好，display:none切换显示时visibility，页面产生回流（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流），而visibility切换是否显示时则不会引起回流。</p>

<p>　　60：JavaScript中如何检测一个变量是一个String类型？请写出函数实现</p>

<p>　　typeof(obj) === &ldquo;string&rdquo;</p>

<p>　　typeof obj === &ldquo;string&rdquo;</p>

<p>　　obj.constructor === String</p>

<p>　　61：如何理解闭包？</p>

<p>　　1、定义和用法：当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。</p>

<p>　　2、表现形式：使函数外部能够调用函数内部定义的变量。</p>

<p>　　3、实例如下：</p>

<p>　　(1)、根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到window的变量，没有就返回undefined。这里明显count 是函数内部的flag2 的那个count 。</p>

<p>　　varcount=10; //全局作用域 标记为flag1function add(){</p>

<p>　　varcount=0; //函数全局作用域 标记为flag2</p>

<p>　　returnfunction(){</p>

<p>　　count+=1; //函数的内部作用域alert(count);</p>

<p>　　}</p>

<p>　　}vars = add()</p>

<p>　　s();//输出1</p>

<p>　　s();//输出2</p>

<p>　　4、变量的作用域</p>

<p>　　要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>

<p>　　变量的作用域分类：全局变量和局部变量。</p>

<p>　　特点：</p>

<p>　　1、函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。</p>

<p>　　2、函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>

<p>　　5、使用闭包的注意点</p>

<p>　　1）滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>

<p>　　2）会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>

<p>　　62：谈谈垃圾回收机制方式及内存管理</p>

<p>　　回收机制方式</p>

<p>　　1、定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</p>

<p>　　2、原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>

<p>　　3、实例如下：</p>

<p>　　function fn1() {</p>

<p>　　varobj = {name: &lsquo;hanzichi&rsquo;, age: 10};</p>

<p>　　}</p>

<p>　　function fn2() {</p>

<p>　　varobj = {name:&lsquo;hanzichi&rsquo;, age: 10};</p>

<p>　　returnobj;</p>

<p>　　}vara = fn1();varb = fn2();</p>

<p>　　fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</p>

<p>　　4、垃圾回收策略：标记清除(较为常用)和引用计数。</p>

<p>　　标记清除：</p>

<p>　　定义和用法：当变量进入环境时，将变量标记&rdquo;进入环境&rdquo;，当变量离开环境时，标记为：&rdquo;离开环境&rdquo;。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</p>

<p>　　到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>

<p>　　引用计数：</p>

<p>　　定义和用法：引用计数是跟踪记录每个值被引用的次数。</p>

<p>　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p>

<p>　　63：判断一个字符串中出现次数最多的字符，统计这个次数</p>

<p>　　varstr = &lsquo;asdfssaaasasasasaa&rsquo;;</p>

<p>　　varjson = {};</p>

<p>　　for(vari = 0; i &lt; str.length; i++) {</p>

<p>　　if(!json[str.charAt(i)]){</p>

<p>　　json[str.charAt(i)] = 1;</p>

<p>　　}else{</p>

<p>　　json[str.charAt(i)]++;</p>

<p>　　}</p>

<p>　　};variMax = 0;variIndex = &ldquo;;for(vari injson){</p>

<p>　　if(json[i]&gt;iMax){</p>

<p>　　iMax = json[i];</p>

<p>　　iIndex = i;</p>

<p>　　}</p>

<p>　　} console.log(&lsquo;出现次数最多的是:&lsquo;+iIndex+&lsquo;出现&rsquo;+iMax+&lsquo;次&rsquo;);</p>

<p>　　64、$(document).ready()方法和window.onload有什么区别？</p>

<p>　　(1)、window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。</p>

<p>　　(2)、$(document).ready()方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。</p>

<p>　　65、 jquery中$.get()提交和$.post()提交有区别吗？</p>

<p>　　相同点：都是异步请求的方式来获取服务端的数据；</p>

<p>　　异同点：</p>

<p>　　1、请求方式不同：$.get()方法使用GET方法来进行异步请求的。$.post()方法使用POST方法来进行异步请求的。</p>

<p>　　2、参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。</p>

<p>　　3、数据传输大小不同：get方式传输的数据大小不能超过2KB而POST要大的多</p>

<p>　　4、安全问题：GET方式请求的数据会被浏览器缓存起来，因此有安全问题。</p>

<p>　　66、jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？（常见）</p>

<p>　　(1)、bind 【jQuery 1.3之前】</p>

<p>　　定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；</p>

<p>　　语法：bind(type,[data],function(eventObject))；</p>

<p>　　特点：</p>

<p>　　(1)、适用于页面元素静态绑定。只能给调用它的时候已经存在的元素绑定事件，不能给未来新增的元素绑定事件。</p>

<p>　　(2)、当页面加载完的时候，你才可以进行bind()，所以可能产生效率问题。</p>

<p>　　实例如下：$( &ldquo;#members li a&rdquo; ).bind( &ldquo;click&rdquo;, function( e ) {} );</p>

<p>　　(2)、live 【jQuery 1.3之后】</p>

<p>　　定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；</p>

<p>　　语法：live(type, [data], fn);</p>

<p>　　特点：</p>

<p>　　(1)、live方法并没有将监听器绑定到自己(this)身上，而是绑定到了this.context上了。</p>

<p>　　(2)、live正是利用了事件委托机制来完成事件的监听处理，把节点的处理委托给了document，新添加的元素不必再绑定一次监听器。</p>

<p>　　(3)、使用live（）方法但却只能放在直接选择的元素后面，不能在层级比较深，连缀的DOM遍历方法后面使用，即$(“ul”&rdquo;).live&hellip;可以，但$(&ldquo;body&rdquo;).find(&ldquo;ul&rdquo;).live&hellip;不行；</p>

<p>　　实例如下：$( document ).on( &ldquo;click&rdquo;, &ldquo;#members li a&rdquo;, function( e ) {} );</p>

<p>　　(3)、delegate 【jQuery 1.4.2中引入】</p>

<p>　　定义和用法：将监听事件绑定在就近的父级元素上</p>

<p>　　语法：delegate(selector,type,[data],fn)</p>

<p>　　特点：</p>

<p>　　(1)、选择就近的父级元素，因为事件可以更快的冒泡上去，能够在第一时间进行处理。</p>

<p>　　(2)、更精确的小范围使用事件代理，性能优于.live()。可以用在动态添加的元素上。</p>

<p>　　实例如下：</p>

<p>　　$(&ldquo;#info_table&rdquo;).delegate(&ldquo;td&rdquo;,&ldquo;click&rdquo;,function(){/<em>显示更多信息</em>/});</p>

<p>　　$(&ldquo;table&rdquo;).find(&ldquo;#info&rdquo;).delegate(&ldquo;td&rdquo;,&ldquo;click&rdquo;,function(){/<em>显示更多信息</em>/});</p>

<p>　　(4)、on 【1.7版本整合了之前的三种方式的新事件绑定机制】</p>

<p>　　定义和用法：将监听事件绑定到指定元素上。</p>

<p>　　语法：on(type,[selector],[data],fn)</p>

<p>　　实例如下：$(&ldquo;#info_table&rdquo;).on(&ldquo;click&rdquo;,&ldquo;td&rdquo;,function(){/<em>显示更多信息</em>/});参数的位置写法与delegate不一样。</p>

<p>　　说明：on方法是当前JQuery推荐使用的事件绑定方法，附加只运行一次就删除函数的方法是one()。</p>

<p>　　总结：.bind(), .live(), .delegate(),.on()分别对应的相反事件为：.unbind(),.die(), .undelegate(),.off()</p>

<p>　　67、px和em的区别（常见）</p>

<p>　　相同点：px和em都是长度单位；</p>

<p>　　异同点：px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。</p>

<p>　　浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。</p>

<p>　　68、浏览器的内核分别是什么</p>

<p>　　IE: trident内核</p>

<p>　　Firefox：gecko内核</p>

<p>　　Safari：webkit内核</p>

<p>　　Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核</p>

<p>　　Chrome：Blink(基于webkit，Google与Opera Software共同开发)</p>

<p>　　69、什么叫优雅降级和渐进增强？（常见）</p>

<p>　　渐进增强 progressive enhancement：</p>

<p>　　针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>

<p>　　优雅降级 graceful degradation：</p>

<p>　　一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>

<p>　　区别：</p>

<p>　　a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给</p>

<p>　　b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p>

<p>　　c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>

<p>　　70、sessionStorage 、localStorage 和cookie 之间的区别（常见）</p>

<p>　　共同点：用于浏览器端存储的缓存数据</p>

<p>　　不同点：</p>

<p>　　(1)、存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；</p>

<p>　　web storage,会将数据保存到本地，不会造成宽带浪费；</p>

<p>　　(2)、数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;</p>

<p>　　(3)、数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器；</p>

<p>　　sessionStorage,仅在关闭浏览器之前有效；localStorage,数据存储永久有效；</p>

<p>　　(4)、作用域不同：cookie和localStorage是在同源同窗口中都是共享的；sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</p>

<hr />

<p><a href="http://www.itcast.cn/news/20181127/14361795506.shtml">传智播客整理的2018web前端开发最新面试试题（含答案）</a></p>

<p>　　传智播客的老师选取整理了部分关于web前端开发考试的一些面试试题来给大家解惑</p>

<pre><code>    开放性题目：  
</code></pre>

<p>　　1、你在现在的团队处于什么样的角色，起到了什么明显的作用？</p>

<p>　　2、说说前端最近流行些什么，在自己以前的项目中都有应用哪些？常去哪些网站？</p>

<p><img src="http://www.itcast.cn/files/image/201811/20181127143512825.jpg" alt="2018web" />
　　技术型题目：</p>

<p>　　1、<strong>请写出目前有哪些主流浏览器及对应的内核是叫什么？</strong></p>

<p>　　1、IE浏览器内核：Trident内核，也被称为IE内核；</p>

<p>　　2、Chrome浏览器内核：Chromium内核 → Webkit内核 → Blink内核；</p>

<p>　　3、Firefox浏览器内核：Gecko内核，也被称Firefox内核；</p>

<p>　　4、Safari浏览器内核：Webkit内核；</p>

<p>　　5、Opera浏览器内核：最初是自主研发的Presto内核，后跟随谷歌，从Webkit到Blink内核；</p>

<p>　　6、360浏览器、猎豹浏览器内核：IE+Chrome双内核；</p>

<p>　　7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；</p>

<p>　　8、百度浏览器、世界之窗内核：IE内核；</p>

<p>　　2、<strong>请解释下JavaScript的同源策略？</strong></p>

<p>　　同源策略简单的说就是一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合。</p>

<p>　　3、<strong>什么是跨域，跨域请求资源的方法有哪些，你是如何解决跨域的？</strong></p>

<p>　　3.1由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。存在跨域的情况：</p>

<p>　　网络协议不同，如http协议访问https协议。</p>

<p>　　端口不同，如80端口访问8080端口。</p>

<p>　　域名不同，如itcast.cn访问itheima.com.com。</p>

<p>　　子域名不同，如www.itcast.cn.com访问web.itcast.cn。</p>

<p>　　域名和域名对应ip,如www.a.com访问20.205.28.99.</p>

<pre><code>    3.2、跨域请求资源的方法：  
</code></pre>

<p>　　(1)、porxy代理</p>

<p>　　定义和用法：proxy代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。</p>

<p>　　实现方法：通过nginx代理；</p>

<p>　　注意点：1、如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。</p>

<p>　　(2)、CORS 【Cross-Origin Resource Sharing】</p>

<p>　　定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。</p>

<p>　　使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：</p>

<p>　　res.writeHead(200, {</p>

<p>　　&rdquo;Content-Type&rdquo;: &ldquo;text/html; charset=UTF-8&rdquo;,</p>

<p>　　&rdquo;Access-Control-Allow-Origin&rdquo;:&lsquo;<a href="http://localhost'">http://localhost'</a>,</p>

<p>　　&rsquo;Access-Control-Allow-Methods&rsquo;: &lsquo;GET, POST, OPTIONS&rsquo;,</p>

<p>　　&rsquo;Access-Control-Allow-Headers&rsquo;: &lsquo;X-Requested-With, Content-Type&rsquo;</p>

<p>　　});</p>

<p>　　(3)、jsonp</p>

<p>　　定义和用法：通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。</p>

<p>　　特点：通过情况下，通过动态创建script来读取他域的动态资源，获取的数据一般为json格式。</p>

<p>　　实例如下：</p>

<p>　　//原生js</p>

<p>　　<html></p>

<p>　　<head></p>

<p>　　<title></title></p>

<p>　　<script type="text/javascript"></p>

<p>　　var returnjs = function(data){</p>

<p>　　alert(data.code);</p>

<p>　　};</p>

<p>　　// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</p>

<p>　　var url = &ldquo;<a href="http://www.itcast.cn/jsonp/get?code=1&amp;callback=returnjs&quot;;//数据接收后台">http://www.itcast.cn/jsonp/get?code=1&amp;callback=returnjs&quot;;//数据接收后台</a></p>

<p>　　// 创建script标签，设置其属性</p>

<p>　　var script = document.createElement(&lsquo;script&rsquo;);</p>

<p>　　script.setAttribute(&lsquo;src&rsquo;, url);</p>

<p>　　// 把script标签加入head，此时调用开始</p>

<p>　　document.getElementsByTagName(&lsquo;head&rsquo;)[0].appendChild(script);</p>

<p>　　</script></p>

<p>　　</head></p>

<p>　　<body></p>

<p>　　</body></p>

<p>　　</html></p>

<p>　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>　　//jQ版</p>

<p>　　&lt;!DOCTYPE html&gt;</p>

<p>　　<html></p>

<p>　　<head></p>

<p>　　<meta charset="UTF-8"></p>

<p>　　<title>Insert title here1</title></p>

<p>　　<script type="text/javascript" src="jq.js"></script><!-- 记得引入jq --></p>

<p>　　</head></p>

<p>　　<body></p>

<p>　　<script type="text/javascript"></p>

<p>　　jQuery(document).ready(function(){</p>

<p>　　$.ajax({</p>

<p>　　type: &ldquo;get&rdquo;,</p>

<p>　　async: false,</p>

<p>　　url: &ldquo;<a href="http://www.itcast.cn.com/jsonp/get?code=1&quot;,//数据接收后台">http://www.itcast.cn.com/jsonp/get?code=1&quot;,//数据接收后台</a></p>

<p>　　dataType: &ldquo;jsonp&rdquo;,</p>

<p>　　jsonp: &ldquo;callback&rdquo;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)</p>

<p>　　jsonpCallback:&ldquo;returnjs&rdquo;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&rdquo;?&ldquo;，jQuery会自动为你处理数据</p>

<p>　　crossDomain:true,</p>

<p>　　success: function(json){</p>

<p>　　alert(json.code);</p>

<p>　　},</p>

<p>　　error: function(){</p>

<p>　　alert(&lsquo;fail&rsquo;);</p>

<p>　　}</p>

<p>　　});</p>

<p>　　});</p>

<p>　　</script></p>

<p>　　</body></p>

<p>　　</html></p>

<p>　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>　　缺点：</p>

<p>　　1、这种方式无法发送post请求（这里）</p>

<p>　　2、另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。</p>

<p>　　4、请说说get和post请求的区别，什么时候用post？</p>

<p>　　1、GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，安全性很低</p>

<p>　　2、POST：一般用于修改服务器上的资源，通过提交表单来传值，对所发送的信息没有限制，安全性比GET高</p>

<p>　　3、在以下情况中，使用 POST 请求：</p>

<p>　　无法使用缓存文件（更新服务器上的文件或数据库）</p>

<p>　　向服务器发送大量数据（POST 没有数据量限制）</p>

<p>　　发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>

<p>　　需要修改服务器上的资源的时候</p>

<p>　　5、<strong>你有哪些性能优化的方法？</strong></p>

<p>　　1. 减少 HTTP 请求</p>

<p>　　2. 减少 DNS 查找</p>

<p>　　3. 避免重定向</p>

<p>　　4. 使用 Ajax 缓存</p>

<p>　　5. 延迟载入组件</p>

<p>　　6. 预先载入组件</p>

<p>　　7. 减少 DOM 元素数量</p>

<p>　　8. 切分组件到多个域</p>

<p>　　9. 最小化 iframe 的数量</p>

<p>　　10. 不要出现http 404 错误</p>

<p>　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>　　6、<strong>请写出函数运行结果。</strong></p>

<p>　　function test(){</p>

<p>　　var a;</p>

<p>　　function foo(){</p>

<p>　　return 2;</p>

<p>　　}</p>

<p>　　console.log(a);//undefined</p>

<p>　　console.log(foo());//2</p>

<p>　　a = 1;</p>

<p>　　}</p>

<p>　　test();</p>

<hr />

<p><a href="http://www.itcast.cn/news/20181127/14043448237.shtml">2018最新web前端面试题附答案</a></p>

<p>1、常用那几种浏览器测试？有哪些内核(Layout Engine)?</p>

<p>　　答：</p>

<p>　　(Q1) 浏览器：IE，Chrome，FireFox，Safari，Opera。</p>

<p>　　(Q2) 内核：Trident，Gecko，Presto，Webkit。</p>

<p>　　2、 说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）</p>

<p>　　答：</p>

<p>　　(Q1) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。</p>

<p>　　块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。</p>

<p>　　(Q2) 兼容性：display:inline-block;*display:inline;*zoom:1;</p>

<p>　　3、 清除浮动有哪些方式？比较好的方式是哪一种？</p>

<p>　　答：</p>

<p>　　(Q1)</p>

<p>　　（1）父级div定义height。</p>

<p>　　（2）结尾处加空div标签clear:both。</p>

<p>　　（3）父级div定义伪类:after和zoom。</p>

<p>　　（4）父级div定义overflow:hidden。</p>

<p>　　（5）父级div定义overflow:auto。</p>

<p>　　（6）父级div也浮动，需要定义宽度。</p>

<p>　　（7）父级div定义display:table。</p>

<p>　　（8）结尾处加br标签clear:both。</p>

<p>　　(Q2) 比较好的是第3种方式，好多网站都这么用。</p>

<p>　　4、box-sizing常用的属性有哪些？分别有什么作用？</p>

<p>　　答：</p>

<p>　　(Q1)box-sizing: content-box|border-box|inherit;</p>

<p>　　(Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。</p>

<p>　　border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</p>

<p>　　5、Doctype作用？标准模式与兼容模式各有什么区别?</p>

<p>　　答：</p>

<p>　　(Q1) 告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p>

<p>　　(Q2) 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p>

<p>　　6、HTML5 为什么只需要写&lt;!DOCTYPE html&gt; ？</p>

<p>　　答：</p>

<p>　　HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。</p>

<p>　　而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>

<p>　　7、 页面导入样式时，使用link和@import有什么区别？</p>

<p>　　答：</p>

<p>　　（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</p>

<p>　　（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>

<p>　　（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。</p>

<p>　　8、介绍一下你对浏览器内核的理解？</p>

<p>　　答：</p>

<p>　　主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</p>

<p>　　渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>

<p>　　JS引擎则：解析和执行javascript来实现网页的动态效果。</p>

<p>　　最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>

<p>　　9、html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</p>

<p>　　答：</p>

<p>　　(Q1)</p>

<p>　　HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>

<p>　　(1)绘画 canvas;</p>

<p>　　(2)用于媒介回放的 video 和 audio 元素;</p>

<p>　　(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</p>

<p>　　(4)sessionStorage 的数据在浏览器关闭后自动删除;</p>

<p>　　(5)语意化更好的内容元素，比如 article、footer、header、nav、section;</p>

<p>　　(6)表单控件，calendar、date、time、email、url、search;</p>

<p>　　(7)新的技术webworker, websocket, Geolocation;</p>

<p>　　(Q2)</p>

<p>　　IE8/IE7/IE6支持通过document.createElement方法产生的标签，</p>

<p>　　可以利用这一特性让这些浏览器支持HTML5新标签，</p>

<p>　　浏览器支持新标签后，还需要添加标签默认的样式。</p>

<p>　　当然也可以直接使用成熟的框架、比如html5shim，</p>

<p>　　10、简述一下你对HTML语义化的理解？</p>

<p>　　答：</p>

<p>　　用正确的标签做正确的事情。</p>

<p>　　html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p>

<p>　　即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</p>

<p>　　搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</p>

<p>　　使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>

<p>　　JavaScript部分</p>

<p>　　1、介绍js的基本数据类型 -<a href="http://web.itcast.cn/">web前端开发培训</a>-<a href="http://www.itcast.cn/">传智播客</a></p>

<p>　　答： Undefined、Null、Boolean、Number、String</p>

<p>　　2、js有哪些内置对象？</p>

<p>　　答：数据封装类对象：Object、Array、Boolean、Number 和 String</p>

<p>　　其他对象：Function、Arguments、Math、Date、RegExp、Error</p>

<p>　　3、this对象的理解</p>

<p>　　答：this总是指向函数的直接调用者（而非间接调用者）；</p>

<p>　　如果有new关键字，this指向new出来的那个对象；</p>

<p>　　在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。</p>

<p>　　4、eval是做什么的？</p>

<p>　　答：它的功能是把对应的字符串解析成JS代码并运行；</p>

<p>　　应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>

<p>　　由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&lsquo;(&rsquo;+ str +&lsquo;)&rsquo;)。</p>

<p>　　5、DOM怎样添加、移除、移动、复制、创建和查找节点</p>

<p>　　答：</p>

<p>　　// 创建新节点</p>

<p>　　createDocumentFragment() //创建一个DOM片段</p>

<p>　　createElement() //创建一个具体的元素</p>

<p>　　createTextNode() //创建一个文本节点</p>

<p>　　// 添加、移除、替换、插入</p>

<p>　　appendChild()</p>

<p>　　removeChild()</p>

<p>　　replaceChild()</p>

<p>　　insertBefore() //在已有的子节点前插入一个新的子节点</p>

<p>　　// 查找</p>

<p>　　getElementsByTagName() //通过标签名称</p>

<p>　　getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</p>

<p>　　getElementById() //通过元素Id，唯一性</p>

<p>　　6、null和undefined的区别？</p>

<p>　　答：</p>

<p>　　null是一个表示&rdquo;无&rdquo;的对象，转为数值时为0；undefined是一个表示&rdquo;无&rdquo;的原始值，转为数值时为NaN。</p>

<p>　　undefined：</p>

<p>　　（1）变量被声明了，但没有赋值时，就等于undefined。</p>

<p>　　（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>

<p>　　（3）对象没有赋值的属性，该属性的值为undefined。</p>

<p>　　（4）函数没有返回值时，默认返回undefined。</p>

<p>　　null：</p>

<p>　　（1） 作为函数的参数，表示该函数的参数不是对象。</p>

<p>　　（2） 作为对象原型链的终点。</p>

<p>　　7、new操作符具体干了什么呢?</p>

<p>　　答：</p>

<p>　　（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>

<p>　　（2）属性和方法被加入到 this 引用的对象中。</p>

<p>　　（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>

<p>　　8、JSON 的了解？</p>

<p>　　答：</p>

<p>　　JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。</p>

<p>　　格式：采用键值对，例如：{&lsquo;age&rsquo;:&lsquo;12&rsquo;, &lsquo;name&rsquo;:&lsquo;back&rsquo;}</p>

<p>　　9、call() 和 apply() 的区别和作用？</p>

<p>　　答：</p>

<p>　　apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。</p>

<p>　　如：function.apply(this,[1,2,3]);</p>

<p>　　call()的第一个参数是上下文，后续是实例传入的参数序列。</p>

<p>　　如：function.call(this,1,2,3);</p>

<p>　　10、如何获取UA？</p>

<p>　　答：</p>

<p>　　function whatBrowser() {</p>

<p>　　document.Browser.Name.value=navigator.appName;</p>

<p>　　document.Browser.Version.value=navigator.appVersion;</p>

<p>　　document.Browser.Code.value=navigator.appCodeName;</p>

<p>　　document.Browser.Agent.value=navigator.userAgent;</p>

<p>　　}</p>

<p>　　其他</p>

<p>　　1、HTTP状态码知道哪些？</p>

<p>　　答：</p>

<p>　　100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</p>

<p>　　200 OK 正常返回信息</p>

<p>　　201 Created 请求成功并且服务器创建了新的资源</p>

<p>　　202 Accepted 服务器已接受请求，但尚未处理</p>

<p>　　301 Moved Permanently 请求的网页已永久移动到新位置。</p>

<p>　　302 Found 临时性重定向。</p>

<p>　　303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</p>

<p>　　304 Not Modified 自从上次请求后，请求的网页未修改过。</p>

<p>　　400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</p>

<p>　　401 Unauthorized 请求未授权。</p>

<p>　　403 Forbidden 禁止访问。</p>

<p>　　404 Not Found 找不到如何与 URI 相匹配的资源。</p>

<p>　　500 Internal Server Error 最常见的服务器端错误。</p>

<p>　　503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p>

<p>　　2、你有哪些性能优化的方法？</p>

<p>　　答：</p>

<p>　　（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p>

<p>　　（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>

<p>　　（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p>

<p>　　（4） 当需要设置的样式很多时设置className而不是直接操作style。</p>

<p>　　（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p>

<p>　　（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p>

<p>　　（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</p>

<p>　　3、 什么叫优雅降级和渐进增强？</p>

<p>　　答：</p>

<p>　　优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。</p>

<p>　　渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>

<p>　　4、哪些常见操作会造成内存泄漏？</p>

<p>　　答：</p>

<p>　　内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p>

<p>　　垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>

<p>　　setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p>

<p>　　闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。</p>

<p>　　5、线程与进程的区别</p>

<p>　　答：</p>

<p>　　一个程序至少有一个进程,一个进程至少有一个线程。</p>

<p>　　线程的划分尺度小于进程，使得多线程程序的并发性高。</p>

<p>　　另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>

<p>　　线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>

<p>　　从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>

<hr />

<p><a href="http://www.itcast.cn/news/20181126/14081881664.shtml">web前端面试试题（html）（附答案）</a></p>

<p>1.Doctype作用?标准模式与兼容模式各有什么区别?</p>

<p>(1)、声明位于位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p>

<p>(2)、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p>

<p>2.HTML5 为什么只需要写 ?</p>

<p><img src="http://www.itcast.cn/files/image/201811/20181126140724195.jpg" alt="传智播客整理的web前端面试试题html" /></p>

<p>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为(让浏览器按照它们应该的方式来运行);</p>

<p>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>

<p>3.行内元素有哪些?块级元素有哪些? 空(void)元素有那些?</p>

<pre style="FONT-SIZE: 12px; FONT-FAMILY: "Courier New" !important; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); PADDING-BOTTOM: 0px; FONT-STYLE: normal; TEXT-ALIGN: left; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: break-word">
首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

（1）行内元素有：a b span img input select strong（强调的语气）
（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p
（3）常见的空元素：
    <br> <hr> <img> <input> <link> <meta>    鲜为人知的是：
    <area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异
</pre>

<p>4.页面导入样式时，使用link和@import有什么区别?</p>

<p>(1)link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用;而@import是CSS提供的，只能用于加载CSS;</p>

<p>(2)页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>

<p>(3)import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</p>

<p>5.介绍一下你对浏览器内核的理解?</p>

<p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</p>

<p>渲染引擎：负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入CSS等)，以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>

<p>JS引擎则：解析和执行javascript来实现网页的动态效果。</p>

<p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>

<p><strong>6.常见的浏览器内核有哪些?</strong></p>

<p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</p>

<p>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</p>

<p>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]</p>

<p>Webkit内核：Safari,Chrome等。 [ Chrome的：Blink(WebKit的分支)]</p>

<p>7.html5有哪些新特性、移除了那些元素?如何处理HTML5新标签的浏览器兼容问题?如何区分 HTML 和 HTML5?</p>

<p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>

<p>绘画 canvas;</p>

<p>用于媒介回放的 video 和 audio 元素;</p>

<p>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</p>

<p>sessionStorage 的数据在浏览器关闭后自动删除;</p>

<p>语意化更好的内容元素，比如 article、footer、header、nav、section;</p>

<p>表单控件，calendar、date、time、email、url、search;</p>

<p>新的技术webworker, websocket, Geolocation;</p>

<p>移除的元素：</p>

<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</p>

<p>对可用性产生负面影响的元素：frame，frameset，noframes;</p>

<p>* 支持HTML5新标签：</p>

<p>IE8/IE7/IE6支持通过document.createElement方法产生的标签，</p>

<p>可以利用这一特性让这些浏览器支持HTML5新标签，</p>

<p>浏览器支持新标签后，还需要添加标签默认的样式。</p>

<p>当然也可以直接使用成熟的框架、比如html5shim;</p>

<p><strong>简述一下你对HTML语义化的理解?</strong></p>

<p>用正确的标签做正确的事情。</p>

<p>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p>

<p>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</p>

<p>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</p>

<p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>

<p><strong>HTML5的离线储存怎么使用，工作原理能不能解释一下?</strong></p>

<p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>

<p>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>

<p>如何使用：</p>

<p>1、页面头部像下面一样加入一个manifest的属性;</p>

<p>2、在cache.manifest文件的编写离线存储的资源;</p>

<p>CACHE MANIFEST</p>

<p>#v0.11</p>

<p>CACHE:</p>

<p>js/app.js</p>

<p>css/style.css</p>

<p>NETWORK:</p>

<p>resourse/logo.png</p>

<p>FALLBACK:</p>

<p>/ /offline.html</p>

<p>3、在离线状态时，操作window.applicationCache进行需求实现。</p>

<p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢?</strong></p>

<p>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p>

<p>离线的情况下，浏览器就直接使用离线存储的资源。</p>

<p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别?</strong></p>

<p>cookie是网站为了标示用户身份而储存在用户本地终端(Client Side)上的数据(通常经过加密)。</p>

<p>cookie数据始终在同源的http请求中携带(即使不需要)，记会在浏览器和服务器间来回传递。</p>

<p>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>

<p>存储大小：</p>

<p>cookie数据大小不能超过4k。</p>

<p>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>

<p>有期时间：</p>

<p>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;</p>

<p>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</p>

<p>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>

<p><strong>iframe有那些缺点?</strong></p>

<p>*iframe会阻塞主页面的Onload事件;</p>

<p>*搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>

<p>*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>

<p>*使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>

<p><strong>Label的作用是什么?是怎么用的?</strong></p>

<p>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>

<p>HTML5的form如何关闭自动完成功能?</p>

<p>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p>

<p><strong>如何实现浏览器内多个标签页之间的通信?</strong></p>

<p>WebSocket、SharedWorker;</p>

<p>也可以调用localstorge、cookies等本地存储方式;</p>

<p>localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，</p>

<p>我们通过监听事件，控制它的值来进行页面信息通信;</p>

<p>注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常;</p>

<p><strong>webSocket如何兼容低浏览器?</strong></p>

<p>Adobe Flash Socket 、</p>

<p>ActiveX HTMLFile (IE) 、</p>

<p>基于 multipart 编码发送 XHR 、</p>

<p>基于长轮询的 XHR</p>

<p><strong>页面可见性(Page Visibility API) 可以有哪些用途?</strong></p>

<p>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</p>

<p>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放;</p>

<p><strong>如何在页面上实现一个圆形的可点击区域?</strong></p>

<p>1、map+area或者svg</p>

<p>2、border-radius</p>

<p>3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</p>

<p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</p>

<p>网页验证码是干嘛的，是为了解决什么安全问题。</p>

<p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水;</p>

<p>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p>

<p><strong>title与h1的区别、b与strong的区别、i与em的区别?</strong></p>

<p>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响;</p>

<p>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而</strong>是展示强调内容。****</p>

<p>*<strong><em>i内容展示为斜体，em表示强调的文本;</em></strong>*</p>

<p>*<strong><em>Physical Style Elements &ndash; 自然样式标签</em></strong>*</p>

<p>*<strong><em>b, i, u, s, pre</em></strong>*</p>

<p>*<strong><em>Semantic Style Elements &ndash; 语义样式标签</em></strong>*</p>

<p>*<strong><em>strong, em, ins, del, code</em></strong>*</p>

<p>*<strong><em>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</em></strong>*</p>

<hr />

<p><a href="http://www.itcast.cn/news/20181126/13431896082.shtml">传智播客整理的web前端JavaScript面试试题（附答案）</a>
<strong>1.介绍js的基本数据类型</strong></p>

<p>Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )<br />
<strong>2.介绍js有哪些内置对象?</strong></p>

<p>Object 是 JavaScript 中所有对象的父对象</p>

<p>数据封装类对象：Object、Array、Boolean、Number 和 String</p>

<p>其他对象：Function、Arguments、Math、Date、RegExp、Error<br />
<strong>3.说几条写JavaScript的基本规范?</strong></p>

<p>1.不要在同一行声明多个变量。</p>

<p>2.请使用 ===/!==来比较true/false或者数值</p>

<p>3.使用对象字面量替代new Array这种形式</p>

<p>4.不要使用全局函数。</p>

<p>5.Switch语句必须带有default分支</p>

<p>6.函数不应该有时候有返回值，有时候没有返回值。</p>

<p>7.For循环必须使用大括号</p>

<p>8.If语句必须使用大括号</p>

<p>9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>

<p><strong>4.JavaScript原型.原型链 ? 有什么特点?</strong></p>

<p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，</p>

<p>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，</p>

<p>于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>

<p>关系：instance.constructor.prototype = instance.<strong>proto</strong></p>

<p>特点：</p>

<p>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>

<p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，</p>

<p>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。</p>

<p>function Func(){}</p>

<p>Func.prototype.name = &ldquo;Sean&rdquo;;</p>

<p>Func.prototype.getInfo = function() {</p>

<p>return this.name;</p>

<p>}</p>

<p>var person = new Func();//现在可以参考var person = Object.create(oldObject);</p>

<p>console.log(person.getInfo());//它拥有了Func的属性和方法</p>

<p>//&ldquo;Sean&rdquo;</p>

<p>console.log(Func.prototype);</p>

<p>// Func { name=&ldquo;Sean&rdquo;, getInfo=function()}</p>

<p><strong>5.JavaScript有几种类型的值?，你能画一下他们的内存图吗?</strong></p>

<p>栈：原始数据类型(Undefined，Null，Boolean，Number、String)</p>

<p>堆：引用数据类型(对象、数组和函数)</p>

<p>两种类型的区别是：存储位置不同;</p>

<p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储;</p>

<p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能;引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>

<p>如何将字符串转化为数字，例如&rsquo;12.3b&rsquo;?</p>

<p>* parseFloat(&lsquo;12.3b&rsquo;);</p>

<p>* 正则表达式，&rsquo;12.3b&rsquo;.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</p>

<p>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?</p>

<p>function commafy(num){</p>

<p>return num &amp;&amp; num</p>

<p>.toString()</p>

<p>.replace(/(\d)(?=(\d{3})+.)/g, function($1, $2){</p>

<p>return $2 + &lsquo;,&rsquo;;</p>

<p>});</p>

<p>}</p>

<p><strong>如何实现数组的随机排序?</strong></p>

<p>方法一：</p>

<pre><code class="language-javascript">
function randSort1(arr){

for(var i = 0,len = arr.length;i &lt; len; i++ ){

var rand = parseInt(Math.random()*len);

var temp = arr[rand];

arr[rand] = arr[i];

arr[i] = temp;

}

return arr;

}

console.log(randSort1(arr));

</code></pre>

<p>方法二：</p>

<pre><code class="language-javascript">
var arr = [1,2,3,4,5,6,7,8,9,10];

function randSort2(arr){

var mixedArray = [];

while(arr.length &gt; 0){

var randomIndex = parseInt(Math.random()*arr.length);

mixedArray.push(arr[randomIndex]);

arr.splice(randomIndex, 1);

}

return mixedArray;

}

console.log(randSort2(arr));

</code></pre>

<p>方法三：</p>

<pre><code class="language-javascript">
var arr = [1,2,3,4,5,6,7,8,9,10];

arr.sort(function(){

return Math.random() - 0.5;

})

console.log(arr);

</code></pre>

<p><strong>Javascript如何实现继承?</strong></p>

<p>1、构造继承</p>

<p>2、原型继承</p>

<p>3、实例继承</p>

<p>4、拷贝继承</p>

<p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。</p>

<pre><code class="language-javascript">
function Parent(){

this.name = 'wang';

}

function Child(){

this.age = 28;

}

Child.prototype = new Parent();//继承了Parent，通过原型

var demo = new Child();

alert(demo.age);

alert(demo.name);//得到被继承的属性

</code></pre>

<hr />

<p><a href="http://www.itcast.cn/news/20181126/13213856110.shtml">web前端面试题（汇总）</a></p>

<p><strong><a href="http://web.itcast.cn/">web前端</a>面试题（汇总）</strong><br />
一、理论知识</p>

<p>1.1、讲讲输入完网址按下回车，到看到网页这个过程中发生了什么</p>

<p>a. 域名解析</p>

<p>b. 发起TCP的3次握手</p>

<p>c. 建立TCP连接后发起http请求</p>

<p>d. 服务器端响应http请求，浏览器得到html代码</p>

<p>e. 浏览器解析html代码，并请求html代码中的资源</p>

<p>f. 浏览器对页面进行渲染呈现给用户</p>

<p><strong>参考《一次完整的HTTP事务是怎样一个过程》</strong></p>

<p><strong><img src="http://www.itcast.cn/files/image/201811/20181126132046911.jpg" alt="web前端面试试题" /></strong></p>

<p>1.2、谈谈你对前端性能优化的理解</p>

<p>a. 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</p>

<p>b. 请求带宽：开启GZip，精简JavaScript，移除重复脚本，图像优化，将icon做成字体</p>

<p>c. 缓存利用：使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</p>

<p>d. 页面结构：将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</p>

<p>e. 代码校验：避免CSS表达式，避免重定向</p>

<p><strong>参考《前端工程与性能优化》</strong></p>

<p>1.3、前端 MV*框架的意义</p>

<p>早期前端都是比较简单，基本以页面为工作单元，内容以浏览型为主，也偶尔有简单的表单操作，基本不太需要框架.</p>

<p>随着 AJAX 的出现，Web2.0的兴起，人们可以在页面上可以做比较复杂的事情了，然后前端框架才真正出现了。</p>

<p>如果是页面型产品，多数确实不太需要它，因为页面中的 JavaScript代码，处理交互的绝对远远超过处理模型的，但是如果是应用软件类产品，这就太需要了。</p>

<p>长期做某个行业软件的公司，一般都会沉淀下来一些业务组件，主要体现在数据模型、业务规则和业务流程，这些组件基本都存在于后端，在前端很少有相应的组织。</p>

<p>从协作关系上讲，很多前端开发团队每个成员的职责不是很清晰，有了前端的 MV框架，这个状况会大有改观。</p>

<p>之所以感受不到 MV*框架的重要性，是因为Model部分代码较少，View的相对多一些。如果主要在操作View和Controller，那当然 jQuery 这类库比较好用了。</p>

<p><strong>参考《前端 MV*框架的意义》</strong></p>

<p>1.4、请简述盒模型</p>

<p>IE6盒子模型与W3C盒子模型。</p>

<p>文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。</p>

<p>CSS3中有个box-sizing属性可以控制盒子的计算方式，</p>

<p>content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。(W3C盒子模型)</p>

<p>border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。(IE6盒子模型)</p>

<p><strong>参考《盒模型》</strong></p>

<p>1.5、请你谈谈Cookie的弊端</p>

<p>a. 每个特定的域名下最多生成的cookie个数有限制</p>

<p>b. IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie</p>

<p>c. cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节</p>

<p>d. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。</p>

<p>1.6、浏览器本地存储</p>

<p>在HTML5中提供了sessionStorage和localStorage.</p>

<p>sessionStorage用于本地存储一个会话(session)中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。</p>

<p>localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>

<p>1.7、web storage和cookie的区别</p>

<p>a. Cookie的大小是受限的</p>

<p>b. 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽</p>

<p>c. cookie还需要指定作用域，不可以跨域调用</p>

<p>d. Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie</p>

<p>e. Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p>

<p>f. IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage</p>

<p>1.9、线程与进程的区别</p>

<p>a. 一个程序至少有一个进程，一个进程至少有一个线程</p>

<p>b. 线程的划分尺度小于进程，使得多线程程序的并发性高</p>

<p>c. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p>

<p>d. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>

<p>e. 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</p>

<p>1.10、请说出三种减少页面加载时间的方法</p>

<p>a. 尽量减少页面中重复的HTTP请求数量</p>

<p>b. 服务器开启gzip压缩</p>

<p>c. css样式的定义放置在文件头部</p>

<p>d. Javascript脚本放在文件末尾</p>

<p>e. 压缩合并Javascript、CSS代码</p>

<p>f. 使用多域名负载网页内的多个文件、图片</p>

<p><strong>参考《减低页面加载时间的方法》</strong></p>

<p>1.11、你都使用哪些工具来测试代码的性能?</p>

<p>JSPerf, Dromaeo</p>

<p>1.12、你遇到过比较难的技术问题是?你是如何解决的?</p>

<p>1.13、常使用的库有哪些?常用的前端开发工具?开发过什么应用或组件?</p>

<p>1.14、列举IE与其他浏览器不一样的特性?</p>

<p>a. IE的排版引擎是Trident (又称为MSHTML)</p>

<p>b. Trident内核曾经几乎与W3C标准脱节(2005年)</p>

<p>c. Trident内核的大量 Bug等安全性问题没有得到及时解决</p>

<p>d. JS方面，有很多独立的方法，例如绑定事件的attachEvent、创建事件的createEventObject等</p>

<p>e. CSS方面，也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式</p>

<p><strong>参考《Trident(排版引擎)》</strong></p>

<p>1.15、什么叫优雅降级和渐进增强?</p>

<p>渐进增强 progressive enhancement：</p>

<p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>

<p>优雅降级 graceful degradation：</p>

<p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>

<p>区别：</p>

<p>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给</p>

<p>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p>

<p>c. 降级(功能衰减)意味着往回看;而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>

<p><strong>参考《优雅降级和渐进增强的区别》</strong></p>

<p>1.16、WEB应用从服务器主动推送Data到客户端有那些方式?</p>

<p>a. html5 websoket</p>

<p>b. WebSocket 通过 Flash</p>

<p>c. XHR长时间连接</p>

<p>d. XHR Multipart Streaming</p>

<p>e. 不可见的Iframe</p>

<p>f.</p>

<hr />

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://xn213.github.io/hugo-blog/tags/%E5%89%8D%E7%AB%AF/">前端</a>

  <a class="tag tag--primary tag--small" href="https://xn213.github.io/hugo-blog/tags/%E9%9D%A2%E8%AF%95/">面试</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://xn213.github.io/hugo-blog/2019/03/ruoxiyy/" data-tooltip="Ruoxiyy">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://xn213.github.io/hugo-blog/2018/07/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-tooltip="《积极心理学》笔记">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/%29">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/%29">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/%29">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 xn213. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://xn213.github.io/hugo-blog/2019/03/ruoxiyy/" data-tooltip="Ruoxiyy">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://xn213.github.io/hugo-blog/2018/07/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/" data-tooltip="《积极心理学》笔记">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/%29">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/%29">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https://xn213.github.io/hugo-blog/2018/11/fe-interview-czbk/%29">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https%3A%2F%2Fxn213.github.io%2Fhugo-blog%2F2018%2F11%2Ffe-interview-czbk%2F%29">
          <i class="fa fa-facebook-official"></i><span>Share on Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https%3A%2F%2Fxn213.github.io%2Fhugo-blog%2F2018%2F11%2Ffe-interview-czbk%2F%29">
          <i class="fa fa-twitter"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://github.com/xn213%25!%28EXTRA%20string=https%3A%2F%2Fxn213.github.io%2Fhugo-blog%2F2018%2F11%2Ffe-interview-czbk%2F%29">
          <i class="fa fa-google-plus"></i><span>Share on Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://s.gravatar.com/avatar/7360686615b1a1a30eecc7fed5cd7171?s=80" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">xn213</h4>
    
      <div id="about-card-bio">余生 倾尽天下</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        FE
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Peking
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://xn213.github.io/hugo-blog/images/cover.png');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://xn213.github.io/hugo-blog/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/xn213.github.io\/hugo-blog\/2018\/11\/fe-interview-czbk\/';
          
            this.page.identifier = '\/2018\/11\/fe-interview-czbk\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'hugo-tranquilpeak-theme';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

